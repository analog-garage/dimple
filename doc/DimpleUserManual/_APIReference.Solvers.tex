\subsection{Solvers}
\label{sec:SolversAPI}

\subsubsection{Solver-Specific Methods}

Each solver supports a series of solver-specific methods, which are described in the following sections.  Solver-specific methods may be available for various objects: a factor-graph, variable, or factor.  In each case, to call a solver-specific method, the method is applied to the solver object, returned by the Solver property.  For example:

\ifmatlab
\begin{lstlisting}
factorGraph.Solver.solverSpecificMethod(arguments);
\end{lstlisting}

\begin{lstlisting}
variable.Solver.solverSpecificMethod(arguments);
\end{lstlisting}

\begin{lstlisting}
factor.Solver.solverSpecificMethod(arguments);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
factorGraph.getSolver().solverSpecificMethod(arguments);
\end{lstlisting}

\begin{lstlisting}
variable.getSolver().solverSpecificMethod(arguments);
\end{lstlisting}

\begin{lstlisting}
factor.getSolver().solverSpecificMethod(arguments);
\end{lstlisting}
\fi


Some solver-specific methods return results, while others do not.  Some solver-specific methods require arguments, while others do not.  \ifmatlab If no arguments are needed, the parentheses are optional. \fi

\ifmatlab

In some cases it is convenient to call solver-specific methods on each element in an array of objects.  Utility methods are provided for this purpose.  Specifically, to call a solver-specific method that has no return value:
\begin{lstlisting}
objectArray.invokeSolverSpecificMethod('methodName', arguments);
\end{lstlisting}

In this case, 'methodName' is a text string with the name of the solver-specific method, and arguments is an optional comma-separated list of arguments to that method.

To call a solver specific method that has a return value:
\begin{lstlisting}
returnArray = objectArray.invokeSolverSpecificMethodWithReturnValue('methodName', arguments);
\end{lstlisting}

In this case, returnArray is a cell-array of the return values of the method, with dimensions equal to the dimensions of the object array.

\fi

\subsubsection{Common Methods}

\para{getMultithreadingManager}

Dimple users can retrieve a MultithreadingManager on which to perform additional actions.

\ifmatlab
\begin{lstlisting}
fg.Solver.getMultithreadingManager()
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.getSolver().getMultithreadingManager()
\end{lstlisting}
\fi

Users can configure both the multithreading mode and the number of workers using the MultithreadingManager.

\subparagraph(Multithreading Modes)

Dimple provides various multithreading algorithms that have different speed advantages depending on the size of the user's graph and FactorTables.  In the future Dimple should be modified to automatically detect the best threading algorithm.  Currently, however, it defaults to the "Phase" multithreading mode and requires the user manually set the mode to change this.  For a given graph, users can try both modes and see which is faster.

The currently supported multithreading modes are:

\begin{itemize}
\item Phase - Divides the schedule into "phases" where each phase contains schedule entries that are entirely independent of one another.  These phases are then easy to parallelize.  
\item SingleQueue - Uses a single queue and a dependency graph to pull off work for each thread on the fly.  
\end{itemize}

The following methods can be used for getting and setting modes:


\ifmatlab

\begin{itemize}
\item fg.Solver.getMultithreadingManager().getModes() - Returns a Java array of enums specifying the valid modes.
\item fg.Solver.getMultithreadingManager().setMode(ModeName) - Allows users to set the mode by string.  Currently "Phase" or "SingleQueue" will work.
\item fg.Solver.getMultithreadingManager().setMode(enum) - Allows users to set the mode by the enums returned by the getModes method.
\end{itemize}

\fi

\ifjava
\begin{itemize}
\item fg.getSolver().getMultithreadingManager().getModes() - Returns an array of enums specifying the valid modes.
\item fg.getSolver().getMultithreadingManager().setMode(ModeName) - Allows users to set the mode by string.  Currently "Phase" or "SingleQueue" will work.
\item fg.getSolver().getMultithreadingManager().setMode(enum) - Allows users to set the mode by the enums returned by the getModes method or with MultithreadingMode.<PhaseName>.
\end{itemize}
\fi

\subparagraph{Setting Number of Threads and Workers}

Dimple provides a ThreadingPool as a singleton for multithreading.  It sets the number of threads in this pool to the number of virtual cores in the user's machine by default.  Users can override this default value.  In addition, Dimple allows users to specify the number of "workers" for a given FactorGraph.  This "NumWorkers" is also set to the number of virtual cores on the user's machine by default.  Whereas NumThreads specifies how many threads are in the threadPool, NumWorkers specifies how work is divided up across the graph.  These workers are run by the thread pool.  Best performance is achieved when NumWorkers and NumThreads are the same.  However, NumThreads is global and shared by all graphs where NumWorkers is specific to a given FactorGraph.

The following methods can be used to change number of workers:

\ifjava
\begin{itemize}
\item fg.getSolver().getMultithreadingManager().getNumWorkers()
\item fg.getSolver().getMultithreadingManager().setNumWorkers(num)
\item fg.getSolver().getMultithreadingManager().setNumWorkersToDefault()
\end{itemize}
\fi

\ifmatlab
\begin{itemize}
\item fg.Solver.getMultithreadingManager().getNumWorkers()
\item fg.Solver.getMultithreadingManager().setNumWorkers(num)
\item fg.Solver.getMultithreadingManager().setNumWorkersToDefault()
\end{itemize}
\fi

The following global methods can be used to set the number of threads in the ThreadPool

\ifmatlab
\begin{itemize}
\item getDimpleNumThreads()
\item setDimpleNumThreads(numThreads)
\item setDimpleNumThreadsToDefault()
\end{itemize}
\fi

\ifjava
\begin{itemize}
\item ThreadPool.getNumThreads()
\item ThreadPool.setNumThreads(numThreads)
\item ThreadPool.setNumThreadsToDefault()
\end{itemize}
\fi


\subsubsection{Sum-Product Solver}

Use of the sum-product solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'SumProduct';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.setSolverFactory(new com.analog.lyric.dimple.solvers.sumproduct.Solver());
\end{lstlisting}
\fi

If no solver is specified, the SumProduct solver is used by default.

The sum-product solver supports only discrete variables.

\para{Methods}

\subpara{setDamping}

The SumProduct solver supports damping, in which messages are damped by replacing each message by a weighted sum of the computed message value and the previous value of that message (when the corresponding edge was most-recently updated).  The damping parameter sets the weighting value:

\[
\mathrm{message} = \mathrm{computedMessage} \cdot (1 - D) + \mathrm{previousMessage} \cdot D
\]

where $D$ is the damping value.  The set Damping method can be used to set the damping value.

\ifmatlab
\begin{lstlisting}
fg.Solver.setDamping(dampingValue);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
solver.setDamping(dampingValue);
\end{lstlisting}
\fi

The dampingValue argument must be in the range from 0 through 1.  If this method is never called, the default damming value of 0 is used.


\subpara{setK}

The SumProduct solver supports the k-best variant of the sum-product algorithm.  Users can set a K value on each factor:

\ifmatlab
\begin{lstlisting}
factor.Solver.setK(K);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
STableFactor sfactor = (STableFactor)f.getSolver();
sfactor.setK(K);
\end{lstlisting}
\fi


The solver will only use the K best values for each variable when calculating output messages on a factor node.

IMPORTANT: k-best and damping are not compatible with each other\footnote{This restriction may be removed in a future version of Dimple.}.


\subsubsection{Min-Sum Solver}

Use of the min-sum solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'MinSum';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.setSolver(new com.analog.lyric.dimple.solvers.minsum.Solver());
\end{lstlisting}
\fi

The MinSum solver only supports discrete variables.

\para{Methods}

\subpara{setDamping}

The MinSum solver supports damping, in which messages are damped by replacing each message by a weighted sum of the computed message value and the previous value of that message (when the corresponding edge was most-recently updated).  The damping parameter sets the weighting value:

\[
\mathrm{message} = \mathrm{computedMessage} \cdot (1 - D) + \mathrm{previousMessage} \cdot D
\]

where $D$ is the damping value.  The set Damping method can be used to set the damping value.

\ifmatlab
\begin{lstlisting}
fg.Solver.setDamping(dampingValue);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
solver.setDamping(dampingValue);
\end{lstlisting}
\fi


The dampingValue argument must be in the range from 0 through 1.  If this method is never called, the default damming value of 0 is used.

Note that damping in the MinSum solver is done on messages in the log-domain, which has slightly different behavior than damping in the probability domain, as is done in the SumProduct solver.


\subpara{setK}

The SumProduct solver supports the k-best variant of the sum-product algorithm.  Users can set a K value on each factor:

\ifmatlab
\begin{lstlisting}
factor.Solver.setK(K);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
STableFactor sfactor = (STableFactor)f.getSolver();
sfactor.setK(K);
\end{lstlisting}
\fi

The solver will only use the K best values for each variable when calculating output messages on a factor node.

IMPORTANT: k-best and damping are not compatible with each other\footnote{This restriction may be removed in a future version of Dimple.}.


\subsubsection{Gibbs Solver}
\label{sec:GibbsSolverAPI}

Use of the Gibbs solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'Gibbs';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.setSolver(new com.analog.lyric.dimple.solvers.gibbs.Solver());
\end{lstlisting}
\fi

The Gibbs solver supports both discrete and real variables.

This solver performs Gibbs sampling on a factor graph.  It supports a variety of output information on the sampled graph, including the best joint sample (lowest energy), marginals of each variable (discrete variables only), and a full set of samples for a user-selected set of variables.  The solver supports both sequential and randomized scan, and it supports tempering with an exponential tempering schedule.

For discrete variables, the Gibbs solver directly samples from the conditional distribution of each variable using a variation of the CDF sampling method.  For real variables, the Gibbs solver uses Slice sampling by default.  Optionally, the Metropolis-Hastings algorithm may be used instead.

In cases where the factors of the graph support a conjugate distribution, the solver will automatically determine this and use the appropriate conjugate sampler.  The following table lists the supported conjugate samplers and the corresponding factors that support them.  The corresponding sampler will be used for a given variable if all of the edges connected to that variable support the same sampler\footnote{Additionally, for the conjugate sampler to be used, the domain of the variable must not be bounded to a range smaller than the natural range of the corresponding distribution.}.

\begin{longtable} {l p{7.1cm} p{2.5cm}}
Sampler & Built-in Factor & Edge \\
\hline
\endhead
BetaSampler & Beta & value \\
 & Binomial & $\rho$ \\
DirichletSampler & Dirichlet & value \\
 & Categorical & $\alpha$ \\
 & DiscreteTransition & $\alpha$ \\
GammaSampler & Gamma & value, $\beta$ \\
 & NegativeExpGamma & $\beta$ \\
 & Normal & $\tau$ \\
 & LogNormal & $\tau$ \\
 & CategoricalUnnormalizedParameters & $\tau$ \\
 & DiscreteTransitionUnnormalizedParameters & $\alpha$ \\
NegativeExpGammaSampler & NegativeExpGamma & value \\
 & CategoricalEnergyParameters & $\alpha$ \\ 
 & DiscreteTransitionEnergyParameters & $\alpha$ \\ 
NormalSampler & Normal & value, $\mu$ \\
 & LogNormal & $\mu$ \\
\end{longtable}


The Gibbs solver automatically performs block-Gibbs updates for variables that are deterministically related.  The Gibbs solver automatically detects deterministic relationships associated with built-in deterministic factor functions (see section~\ref{sec:builtInFactors} for a list of these functions).  

\ifmatlab
For user-defined factors specified by MATLAB factor functions or factor tables, the Gibbs solver will detect if they are deterministic functions as along as the factor is marked as the directed outputs are indicated using the DirectedTo property, as described in section~\ref{sec:Factor.DirectedTo}.
\fi

\ifjava
For user-defined factors specified by factor functions or factor tables, the Gibbs solver will detect if they are deterministic functions as along as the factor is marked as the directed outputs are indicated using the DirectedTo property, as described in section~\ref{sec:Factor.DirectedTo}.
\fi
 

\para{Methods}

Most Dimple methods work more-or-less as normal when using the Gibbs solver, but in some cases the interpretation is slightly different. For example, the .Belief method for a discrete variable returns an estimate of the belief based on averaging over the sample values.

NOTE: The setNumIterations() method is not supported by the Gibbs solver as the term ``iteration'' is ambiguous in this case. Instead, the method setNumSamples() should be used to set the length of the run. The Solver.iterate() method performs a single-variable update in the case of the Gibbs solver, rather than an entire scan of all variables.

The following sections list the solver-specific methods for the Gibbs solver.

\subpara{Graph Methods}

The following methods are available on a graph set to use the Gibbs solver:

\ifmatlab
\begin{lstlisting}
graph.Solver.setNumSamples(numSamples);
graph.Solver.getNumSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setNumSamples(numSamples);
graph.getSolver().getNumSamples();
\end{lstlisting}
\fi

Set/get the number of samples to be run when solving the graph (post burn-in).

\ifmatlab
\begin{lstlisting}
graph.Solver.setScansPerSample(scansPerSample);
graph.Solver.getScansPerSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setScansPerSample(scansPerSample);
graph.getSolver().getScansPerSample();
\end{lstlisting}
\fi

Set the number of scans between samples as an alternative means of specifying the sample rate. A scan is an update of the number of variables equal to the total number of variables in the graph.

\ifmatlab
\begin{lstlisting}
graph.Solver.setUpdatesPerSample(updatesPerSample);
graph.Solver.getUpdatesPerSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setUpdatesPerSample(updatesPerSample);
graph.getSolver().getUpdatesPerSample();
\end{lstlisting}
\fi


Set/get the number of single-variable updates between samples.

\ifmatlab
\begin{lstlisting}
graph.Solver.setBurnInScans(burnInScans);
graph.Solver.getBurnInScans();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setBurnInScans(burnInScans);
graph.getSolver().getBurnInScans();
\end{lstlisting}
\fi

Set the number of scans for burn-in as an alternative means of specifying the burn-in period.

\ifmatlab
\begin{lstlisting}
graph.Solver.setBurnInUpdates(burnInUpdates);
graph.Solver.getBurnInUpdates();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setBurnInUpdates(burnInUpdates);
graph.getSolver().getBurnInUpdates();
\end{lstlisting}
\fi

Set/get the number of single-variable updates for the burn-in period prior to collecting samples.

\ifmatlab
\begin{lstlisting}
graph.Solver.setNumRestarts(numRestarts)
graph.Solver.getNumRestarts() 
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setNumRestarts(numRestarts)
graph.getSolver().getNumRestarts() 
\end{lstlisting}
\fi

Set/get the number of random restarts (zero by default, which means run once and don't restart).  For a value greater than zero, the after running the specified number of samples, the solver is restarted with the variable values randomized, and re-run (including burn-in).  The sample values (the best sample value, or all samples, if requested) are extracted across all runs.

Variable initialization (both on the first run and subsequent restarts) is randomized whenever possible.  For a discrete variable, the value is sampled from the Input (uniform if an input is not specified).  For a real variable, if an Input is specified and the Input supports one of the conjugate samplers listed above, that sampler is used to initialize the variable.  If bounds are also specified for the variable domain, the values is truncated to fall within the bounds.  If only bounds are specified (which are finite above and below), then the value is uniformly sampled from within the bounds.  If no finite bounds are specified and there is no input, the variable is initialized to zero (or the value specified by setInitialSampleValue) on the initial run, and left at the final value of the previous run on restart.


\ifmatlab
\begin{lstlisting}
graph.Solver.setDefaultRealSampler(samplerName);
graph.Solver.getDefaultRealSampler();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setDefaultRealSampler(samplerName);
graph.getSolver().getDefaultRealSampler();
\end{lstlisting}
\fi

Set/get the default sampler for Real, Complex, and RealJoint variables.  The default sampler can only be set to one of the generic MCMC samplers.  In the current version of Dimple, the available MCMC samplers are:

\begin{itemize}
\item 'SliceSampler'
\item 'MHSampler'
\end{itemize}

The SliceSampler is the default sampler unless overridden by this method.


\ifmatlab
\begin{lstlisting}
graph.Solver.setInitialTemperature(initialTemperature);
graph.Solver.getInitialTemperature();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setInitialTemperature(initialTemperature);
graph.getSolver().getInitialTemperature();
\end{lstlisting}
\fi

Set/get the initial temperature when using tempering. Note that setting the initial temperature automatically enables the use of tempering if it had not been enabled already.

\ifmatlab
\begin{lstlisting}
graph.Solver.setTemperingHalfLifeInSamples();
graph.Solver.getTemperingHalfLifeInSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setTemperingHalfLifeInSamples();
graph.getSolver().getTemperingHalfLifeInSamples();
\end{lstlisting}
\fi


Set/get the tempering half-life.  the number of samples for the temperature to decrease by half. Note that setting the tempering half-life automatically enables the use of tempering if it had not been enabled already.

\ifmatlab
\begin{lstlisting}
graph.Solver.enableTempering();
graph.Solver.disableTempering();
graph.Solver.isTemperingEnabled();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().enableTempering();
graph.getSolver().disableTempering();
graph.getSolver().isTemperingEnabled();
\end{lstlisting}
\fi

Enable or disable the use of tempering, or determine if tempering is in use.

\ifmatlab
\begin{lstlisting}
graph.Solver.setTemperature(T);
graph.Solver.getTemperature();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setTemperature(T);
graph.getSolver().getTemperature();
\end{lstlisting}
\fi

Set/get the current temperature. Setting the current temperature overrides the current annealing temperature.

\ifmatlab
\begin{lstlisting}
graph.Solver.saveAllSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().saveAllSamples();
\end{lstlisting}
\fi

Prior to solving the graph, this method instructs the solver to save all sample values for all variables. Note that this is practical only for relatively small graphs with relatively small number of samples.

\ifmatlab
\begin{lstlisting}
graph.Solver.saveAllScores();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().saveAllScores();
\end{lstlisting}
\fi

Prior to solving the graph, this method instructs the solver to save the score value (see section~\ref{sec:FactorGraph.Score}) of the graph for each sample.

\ifmatlab
\begin{lstlisting}
graph.Solver.getAllScores();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().getAllScores();
\end{lstlisting}
\fi

Returns an array including the score value for each sample. This method only returns a non-empty value if .saveAllScores() method had previously been called on the graph.

\ifmatlab
\begin{lstlisting}
graph.Solver.setSeed(seed);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setSeed(seed);
\end{lstlisting}
\fi

Set the random seed used for sampling (and used for random scan, if that schedule is used). Setting the seed allows repeatable execution of the Gibbs solver.

\ifmatlab
\begin{lstlisting}
graph.Solver.getTotalPotential();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().getTotalPotential();
\end{lstlisting}
\fi

After running the solver, returns the total potential (score) over all factors of the graph (including input priors on variables) given the most recent sample values.

\ifmatlab
\begin{lstlisting}
graph.Solver.sample(numSamples)
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().sample(numSamples)
\end{lstlisting}
\fi

This method runs a specified number of samples without re-initializing, burn-in, or random-restarts (this is distinct from iterate(), which runs a specified number of single-variable updates).  Before running this method for the first time, the graph must be initialized using the initialize() method.

\ifmatlab
\begin{lstlisting}
graph.Solver.burnIn()
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().burnIn()
\end{lstlisting}
\fi

Run the burn-in samples independently of using solve (which automatically runs the burn-in samples).  This may be run before using sample() or iterate().

\subpara{Variable Methods}

\ifmatlab
\begin{lstlisting}
variable.Solver.getCurrentSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getCurrentSample();
\end{lstlisting}
\fi

Returns the current sample value for a variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getAllSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getAllSamples();
\end{lstlisting}
\fi

Returns an array including all sample values seen so far for a variable. Over multiple variables, samples with the same index correspond to the same joint sample value. This method only returns a non-empty value if .saveAllSamples() method had previously been called on the graph or for the variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getBestSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getBestSample();
\end{lstlisting}
\fi


Returns the value of the best sample value seen so far, where best is defined as the sample with the minimum total potential over the graph (sum of -log of the factor values and input priors).  When getting the best sample from multiple variables, they all correspond to the same sample in time, thus should be a valid sample from the joint distribution.

\ifmatlab
\begin{lstlisting}
variable.Solver.saveAllSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().saveAllSamples();
\end{lstlisting}
\fi

Prior to solving the graph, this method instructs the solver to save all sample values for this variable.

\subpara{Discrete-Variable-Specific Methods}

\ifmatlab
\begin{lstlisting}
variable.Solver.getSampleIndex;
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getSampleIndex();
\end{lstlisting}
\fi

Returns the index of the current sample for a variable, where the index refers to the index into the domain of the variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getAllSampleIndices;
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getAllSampleIndices();
\end{lstlisting}
\fi

Returns an array including the indices of all samples seen so far for a variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getBestSampleIndex;
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getBestSampleIndex();
\end{lstlisting}
\fi

Returns the index of the best sample seen so far.

\subpara{Real-Variable-Specific Methods}

The following methods apply to Real, RealJoint, and Complex variables when using the Gibbs solver.

\ifmatlab
\begin{lstlisting}
variable.Solver.setSampler(samplerName);
variable.Solver.getSampler();
variable.Solver.getSamplerName();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setSampler(samplerName);
variable.getSolver().getSampler();
variable.getSolver().getSamplerName();
\end{lstlisting}
\fi

Set/get the sampler to be used for this variable.  The sampler can only be set to one of the generic MCMC samplers (not a conjugate sampler, which will be used automatically if the conditions are met).  Setting the sampler for a given variable overrides any conjugate sampler that might otherwise be used.  In the current version of Dimple, the available MCMC samplers are:

\begin{itemize}
\item 'SliceSampler'
\item 'MHSampler'
\end{itemize}

The SliceSampler is used by default, unless the default is overridden for the graph using the setDefaultRealSampler method.

The MHSampler uses the Metropolis-Hastings algorithm.  For the MHSampler, the Gaussian proposal distribution is used, with a standard deviation that can be set using the following method:

\ifmatlab
\begin{lstlisting}
variable.Solver.setProposalStandardDeviation(stdDev)
variable.Solver.getProposalStandardDeviation()
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setProposalStandardDeviation(stdDev)
variable.getSolver().getProposalStandardDeviation()
\end{lstlisting}
\fi

Set/get the standard deviation for a Gaussian proposal distribution (the default is 1).

\ifmatlab
\begin{lstlisting}
variable.Solver.setInitialSampleValue(initialSampleValue)
variable.Solver.getInitialSampleValue()
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setInitialSampleValue(initialSampleValue)
variable.getSolver().getInitialSampleValue()
\end{lstlisting}
\fi

Set/get the initial sample value that is a starting point for the proposal distribution (the default is 0).  This value is used only on the first run (not subsequent restarts) and only if it is not possible to generate a random starting value.

\subpara{Factor Methods}

\ifmatlab
\begin{lstlisting}
factor.Solver.getPotential();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
factor.getSolver().getPotential();
\end{lstlisting}
\fi

Returns the potential value of a factor given the current values of its connected variables.

\ifmatlab
\begin{lstlisting}
factor.Solver.getPotential(values);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
factor.getSolver().getPotential(values);
\end{lstlisting}
\fi

Get the potential value of a factor given the variable values specified by the argument vector. The argument must be a vector with length equal to the number of connected variables. For a table-factor (connected exclusively to discrete variables), each value corresponds the index into the domain list for that variable (not the value of the variable itself). For a real-factor (connected to one or more real variables), each value corresponds to the value of the variable.

\para{Schedulers}

The built-in schedulers designed for belief propagation are not appropriate for the Gibbs solver.  Instead, there are two built-in schedulers specifically for the Gibbs solver:

\begin{itemize}
\item GibbsSequentialScanScheduler
\item GibbsRandomScanScheduler
\end{itemize}

The GibbsSequentialScanScheduler chooses the next variable for updating in a fixed order. It updates all variables in the graph, completing an entire scan, before repeating the same fixed order. (In Gibbs literature this seems to be known as a sequential-scan, systematic-scan, or fixed-scan schedule.)

The GibbsRandomScanScheduler randomly selects a variable for each update (with replacement).

The default scheduler when using the Gibbs solver is the GibbsSequentialScanScheduler, which is used if no scheduler is explicitly specified.

The user may specify a custom schedule when using the Gibbs solver.  In this case, the schedule should include only Variable node updates (not specific edges), and no Factor updates (any Factor updates specified will be ignored).

To explicitly specify a scheduler, use the Scheduler or Schedule property of the FactorGraph (see sections~\ref{sec:FactorGraph.Scheduler} and~\ref{sec:FactorGraph.Schedule}).



\subsubsection{Gaussian Solver}

Use of the Gaussian solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'Gaussian';
\end{lstlisting}
\fi

\ifmatlab
\begin{lstlisting}
fg.setSolver(new com.analog.lyric.dimple.solvers.gaussian.Solver());
\end{lstlisting}
\fi

\para{Univariate Gaussian}

\para{High Level View of the Gaussian Solver Math}

The Gaussian solver passes means and variances along the Factor Graph edges. It provides two factors that analytically calculate the outgoing messages. The first is a factor for addition and the second is a factor for multiplication by a constant.

Users can create additional factors that use sampling by overriding the GaussianFactorFunction class. The user is required to override two methods: acceptanceRatio and generateSample. These will be described in a later section.

\para{Creating Variables and a Graph}

The Gaussian solver currently works only with real variables. (We will eventually enhance it to work with Discrete variables as well). The following is an example of how to create a Factor Graph that will eventually use the Gaussian solver:

\ifmatlab
\begin{lstlisting}
a = Real(3,1);
mu = 3;
sigma = 4;
a(1).Input = [mu sigma];  
mu2 = 10;
sigma2 = 2;
a(2).Input = [mu2 sigma2];

fg = FactorGraph();
fg.Solver = 'Gaussian';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
Real a1 = new Real();
Real a2 = new Real();
Real a3 = new Real();
double mu = 3;
double sigma = 4;
a1.setInputObject(new double [] {mu,sigma});
double mu2 = 10;
double sigma2 = 2;
a2.setInputObject(new double [] {mu2,sigma2});
FactorGraph fg = new FactorGraph(); 
fg.setSolverFactory(new com.analog.lyric.dimple.solvers.gaussian.Solver());
\end{lstlisting}
\fi

We have not yet added a factor, so the real variables indicated by a are not yet associated with the FactorGraph.

\para{Add}

As mentioned previously, the add function is implemented analytically. The following code demonstrates how to implement a factor graph that imposes the constraint that a=b+c

\ifmatlab
\begin{lstlisting}
a = Real();
b = Real();
c = Real();
 
mus = [8 10 -1];
sigmas = [1 2 3];

a.Input = [mus(1) sigmas(1)];
b.Input = [mus(2) sigmas(2)];
c.Input = [mus(3) sigmas(3)];

fg = FactorGraph();
fg.Solver = 'Gaussian';

f = fg.addFactor(@add,a,b,c);

fg.solve();
\end{lstlisting}

Note that the @add syntax in MATLAB implies that add is a method and @add is a function handle. Users do not have to define an add function or worry about an existing add function since Dimple matches the function name to its custom add factor.

Note that the addition factor could alternatively have been added using the overloaded plus operator:

\begin{lstlisting}
a = b + c;
\end{lstlisting}


\fi

\ifjava
\begin{lstlisting}
Real a = new Real();
Real b = new Real();
Real c = new Real();
		 
a.setInputObject(new double [] {8,1});
b.setInputObject(new double [] {10,2});
c.setInputObject(new double [] {-1,3});

FactorGraph fg = new FactorGraph();
fg.setSolverFactory(new com.analog.lyric.dimple.solvers.gaussian.Solver());

Factor f = fg.addFactor(new NopFactorFunction("add"),a,b,c);

fg.solve();
\end{lstlisting}

Note that the NopFactorFunction is simply used to provide a factor function with the "add" name.  The gaussian solver provides a custom factor for functions named "add".
\fi


\para{Multiply by Constant}

The constmult factor adds a constraint that a=bc or a=cb. The product should be the left most argument to the addFactor call.

\ifmatlab
\begin{lstlisting}
fg = FactorGraph();
a = Real();
b = Real();
c = 5;

fg.Solver = 'Gaussian';
fg.addFactor(@constmult,a,b,c);
a.Input = [10 1];
fg.solve();

assertEqual(b.Belief,[10/5; 1/5]);
     
a.Input = [0 Inf];
b.Input = [10, 1];
   
fg.solve();
    
assertEqual(a.Belief,[10*5; 1*5]);
\end{lstlisting}


Note that the constant multiplication factor could alternatively have been added using the overloaded product operator, with one of the arguments being a constant:

\begin{lstlisting}
a = b * c;
\end{lstlisting}

\fi

\ifjava
\begin{lstlisting}
FactorGraph fg = new FactorGraph();
Real a = new Real();
Real b = new Real();
double c = 5;

fg.setSolverFactory(new com.analog.lyric.dimple.solvers.gaussian.Solver());		
fg.addFactor(new NopFactorFunction("constmult"),a,b,c);
a.setInputObject(new double [] {10,1});
fg.solve();

double [] belief = (double[])b.getBeliefObject();

System.out.println(belief[0] - 10.0/5);
System.out.println(belief[1] - 1.0/5);

a.setInputObject(new double [] {0,Double.POSITIVE_INFINITY});
b.setInputObject(new double [] {10,1});
fg.solve();

belief = (double[])a .getBeliefObject();

System.out.println(belief[0] - 10.0*5);
System.out.println(belief[1] - 1.0*5);
\end{lstlisting}
\fi



\para{Linear Factor}

Assuming you want to specify the following constraint:

\[
 \sum_i x_i c_i = total
\]

where c is a vector of constants and x is a vector of variables and total is a constant, you can use the Gaussian solver linear factor:

\ifmatlab
\begin{lstlisting}
fg = FactorGraph();
fg.Solver = 'Gaussian';

x1 = Real();
x2 = Real();
x3 = Real();
consts = [1 2 3];
total = 6;
fg.addFactor(@linear,x1,x2,x3,consts,total);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
FactorGraph fg = new FactorGraph();
fg.setSolverFactory(new com.analog.lyric.dimple.solvers.gaussian.Solver());

Real x1 = new Real();
Real x2 = new Real();
Real x3 = new Real();
double [] consts = new double [] {1,2,3};
double total = 6;
fg.addFactor(new NopFactorFunction("linear"),x1,x2,x3,consts,total);
\end{lstlisting}
\fi



\para{General Factors}

The Gaussian Solver provides a mechanism to support general factors that cannot calculate messages analytically and require sampling methods instead. The user must provide several methods:

\begin{itemize}
\item For each edge of the factor:
\begin{itemize}
\item A (first) function that is passed sample values of all of the \emph{other} edges, and returns a value between 0 and 1.
\begin{itemize}
\item This function represents the integral or sum of the factor function over the variable associated with this edge (scaled to be between 0 and 1). For example, if the factor is $F(x,y,z)$, then for variable $z$, this would return $\frac{H_{z}(x,y)}{\max(H_{z})}$, where $H_{z}(x,y) = \int_z F(x,y,z) dz$, and $\max(H_{z})$ is the maximum value of $H_{z}(x,y)$ over all values of $x$ and $y$. For output variable $y$, it would return a similar function, but integrated over $y$ instead of $z$; and for output variable $x$, integrated over $x$. If a particular variable is discrete, this sum can be done in software. For real variables, the user would be responsible for this integration.
\end{itemize}
\item A (second) function that is passed sample values of all of the \emph{other} edges, and returns a sample from the conditional probability of the variable associated with this edge given a value for all other edges. It is up to the user to write the code to sample from this distribution.
\begin{itemize}
\item For example, if the factor is $F(x,y,z)$, then for variable $z$, this would return $Z \sim p(z|x,y) = \frac{F(x,y,z) }{ H_{z}(x,y)}$, where $H_{z}(x,y)$ is as defined above. In some cases, such as certain factors that are single-valued in a given direction, $p(z|x,y)$ may be deterministic in which case no sampling is required. In other cases, such as deterministic factors that are multi-valued in a given direction, the sampling is uniform among a small set of values. In other cases, it may be more difficult.
\end{itemize}
\end{itemize}
\end{itemize}


The Dimple Gaussian solver uses those methods as follows:

\begin{itemize}
\item For some number of samples
\begin{itemize}
\item Until a sample is accepted
\begin{itemize}
\item For each input message (mean/variance)
\begin{itemize}
\item Generate a new sample using the specified mean/variance
\end{itemize}
\item Call the first user-method for the given output edge, which returns a value $H$ (the function that returns $\frac{H_{z}(x,y) }{\max(H_{z})}$ in the example above)
\item Choose a random number $U$ from 0 to 1
\item If $U < H$, then accept the new set of input edge sample values, and break
\item Otherwise, continue
\end{itemize}
\item Call the second user-method for the given output edge using the accepted input values are arguments, which returns a sample $Z$ (the function that returns $Z \sim p(z|x,y)$ in the example above)
\item Add the sample $Z$ to a list of output sample values
\end{itemize}
\item For all output sample values
\begin{itemize}
\item Calculate the sample mean
\item Calculate the sample variance
\item Set the output message to these values
\end{itemize}
\end{itemize}



\para{The Factor}

Users who wish to create their own FactorFunctions to be used with the Gaussian solver must create a class that extends the GaussianFactorFunction provided by Dimple. The user must provide implementations for the acceptanceRatio method and the generateSample method.

\begin{lstlisting}


public class GaussianAddFactorFunction extends HybridSampledBPFactorFunction
{
    @Override
    public double acceptanceRatio(int portIndex, Object... inputs) 
    {
        return 1;
    }

    @Override
    public Object generateSample(int portIndex, Object... inputs) 
    {
        if (portIndex == 0)
        {
	    double sum = 0;
	    for (int i = 0; i < inputs.length; i++)
            {
                sum += (Double)inputs[i];
            }
            return sum;
         }
         else
         {
             double sum = (Double)inputs[0];
             for (int i = 1; i < inputs.length; i++)
             {
                 sum -= (Double)inputs[i];
             }
             return sum;
         }
    }
}
\end{lstlisting}


This class is only useful for demonstration since it simply provides a less precise method for calculating the built-in GaussianAdd factor. Note that the acceptanceRatio method always returns 1 in this instance.

The portIndex indicates which edge of the Factor is being updated (the index of the factor's argument). The inputs array specifies the samples that were generated from all of the edges other than the output edge.

\para{Example}

The following example does the following:


\begin{itemize}
\item Create a Factor Graph and Variable
\item Specify how many samples to generate before calculating an outgoing message.
\item Specify a random seed (for repeatability of testing)
\item For each edge
\begin{itemize}
\item Specify the inputs
\item Add the factor
\item Solve
\item Get the beliefs
\item Remove the factor and replace with the @add factor
\item Solve
\item Get the beliefs
\item Compare the analytic to the sampled result.
\end{itemize}
\end{itemize}


\ifmatlab
\begin{lstlisting}
v = Real(3,1);

fg = FactorGraph();
fg.Solver = 'Gaussian';
fg.Solver.setNumSamples(100000);
fg.Solver.setSeed(0);

%%%%%%%%%%%%%%%%%%%%%%%%
%Test add
inputs = [9 2; ...
          3 2; ...
          6 2];

for i = 1:3
   tmpinputs = inputs;
    
   tmpinputs(i,:) = [0 Inf];
   
   v(1).Input = tmpinputs(1,:);
   v(2).Input = tmpinputs(2,:);
   v(3).Input = tmpinputs(3,:);

   f = fg.addFactor(com.lyricsemi.dimple.test.GaussianAddFactorFunction(),v(1),v(2),v(3));

   fg.solve();

   actualBelief = v(i).Belief;
    
   fg.removeFactor(f);
    
   f = fg.addFactor(@add,v(1),v(2),v(3));

   fg.solve();

   expectedBelief = v(i).Belief;
    
   fg.removeFactor(f);
    
   diff = abs(actualBelief - expectedBelief);
   assertTrue(all(diff < .02));

end
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
Real [] v = new Real[3];
for (int i = 0; i < 3; i++)
	v[i] = new Real();

FactorGraph fg = new FactorGraph();
fg.setSolverFactory(new com.analog.lyric.dimple.solvers.gaussian.Solver());
com.analog.lyric.dimple.solvers.gaussian.SFactorGraph sfg = (com.analog.lyric.dimple.solvers.gaussian.SFactorGraph)fg.getSolver(); 
sfg.setNumSamples(100000);
sfg.setSeed(0);

////////////////////
//Test add
double [][] inputs = new double [][] {
	new double [] {9,2},
	new double [] {3,2},
	new double [] {6,2}
};

for (int i = 0; i < 3; i++)
{
	double [][] tmpinputs = inputs.clone();
	tmpinputs[i] = new double [] {0,Double.POSITIVE_INFINITY};

	for (int j = 0; j < 3; j++)
		v[j].setInputObject(tmpinputs[j]);

	Factor f = fg.addFactor(new com.analog.lyric.dimple.factorfunctions.HybridAddFactorFunction(),v[0],v[1],v[2]);

	fg.solve();

	
   double [] actualBelief = (double[]) v[i].getBeliefObject();
    
   fg.remove(f);
    
   f = fg.addFactor(new NopFactorFunction("add"),v[0],v[1],v[2]);

   fg.solve();

   double [] expectedBelief = (double[] )v[i].getBeliefObject();
    
   fg.remove(f);
    
   double diff = 0;
   for (int j = 0; j < 2; j++)
	   diff += Math.pow(actualBelief[j]-expectedBelief[j],2);

   System.out.println(diff);
}
\end{lstlisting}
\fi

Users can specify different numbers of samples to be accrued for each factor.

\ifmatlab
\begin{lstlisting}
f1.setNumSamples(x);
f2.setNumSamples(y);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
((HybridSampledBPFactor)f1).setNumSamples(x);
((HybridSampledBPFactor)f2).setNumSamples(y);
\end{lstlisting}
\fi


where f1 and f2 are objects returned from an addFactor call.


\para{MaxNumTries}

If the user defined FactorFunction provides a low acceptance ratio, it's conceivable a Factor computation might never terminate. The user can specify a maximum number of attempts to be made before throwing an exception:

\ifmatlab
\begin{lstlisting}
fg.Solver.setMaxNumTries(1e6);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.getSolver().setMaxNumTries(1000000);
\end{lstlisting}
\fi

\para{Multivariate Gaussians}
\label{sec:MultivariateGaussians}

The Dimple Gaussian solver provides some support for multivariate Gaussian variables and factors.

\subpara{Variables}

The following code demonstrates the creation and use of a multivariate Gaussian.

\ifmatlab
\begin{lstlisting}
rj = RealJoint(2);
means = [2 3]Õ;
covar = [1 0;
         0 1];
rj.Input = MultivariateMsg(means,covar);
rj.Belief.Means
rj.Belief.Covariance
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
RealJoint rj = new RealJoint(2);
double [] means = new double [] {2,3};
double [][] covar = new double [][] {
		new double [] {1,0},
		new double [] {0,1}
};
rj.setInputObject(new MultivariateMsg(means, covar));
rj.getBeliefObject();
rj.setInput(means,covar);
System.out.println(Arrays.toString(rj.getBelief().getMeans()));
double [][] covarBelief = rj.getBelief().getCovariance();
for (int i = 0; i < covarBelief.length; i++)
	System.out.println(Arrays.toString(covarBelief[i]));
\end{lstlisting}
\fi

Users must create RealJoint variables.  The first argument of the constructor specifies the number of variables in the multivariate Gaussian.  The Gaussian solver expects users to specify a MultivariateMsg type as input to the variable.  This message type takes a mean vector and covariance matrix as arguments.  Beliefs return MultivariateMsg types.


\subpara{Factors}

The Multivariate Gaussian solver supports a matrix multiplication and addition factor.  

\ifmatlab
The following code snippet is taken from the demos/17\_KalmanFilter/run.m file.


\begin{lstlisting}
%F is the state transition model.  (Given current state, what's the next 
%state?)
%new position is a function of old position, velocity, acceleration
%New velocity is old velocity + acceleration
%new acceleration is a function of velocity, friction, and force. 
 
F = [1  0   dt          0           dt^2/2  0       0       0;
    0  1   0           dt          0       dt^2/2  0       0;
    0  0   1           0           dt/2    0       0       0;
    0  0   0           1           0       dt/2    0       0;
    0  0   -gamma/m    0           0       0       Fw(1)   0;
    0  0   0           -gamma/m    0       0       0       Fw(2);
    0  0   0           0           0       0       1       0
    0  0   0           0           0       0       0       1
    ];
 
%H is the matrix that projects down to the observation.
H = [1 0 0 0 0 0 0 0;
    0 1 0 0 0 0 0 0];


fz = RealJoint(2);
fv = RealJoint(2);
fznonoise = RealJoint(2);
fx = RealJoint(8);
fxnext = RealJoint(8);

nested.addFactor(@constmult,fznonoise,H,fx);
nested.addFactor(@add,fz,fv,fznonoise);
nested.addFactor(@constmult,fxnext,F,fx);
\end{lstlisting}
\fi

\ifjava

\begin{lstlisting}

//F is the state transition model.  (Given current state, what's the next 
//state?)
//new position is a function of old position, velocity, acceleration
//New velocity is old velocity + acceleration
//new acceleration is a function of velocity, friction, and force. 

double dt = 1;
double gamma = 1;
double m = 1;

double [][] F = new double [][] {
		new double []{1,0,dt,0,(dt*dt)/2,0,0,0},
		new double []{0,1,0,dt,0,(dt*dt)/2,0,0},
		new double []{0,0,1,0,dt/2,0,0,0},
		new double []{0,0,0,1,0,dt/2,0,0},
		new double []{0,0,-gamma/m,0,0,0,0,0},
		new double []{0,0,0,-gamma/m,0,0,0,0},
		new double []{0,0,0,0,0,0,1,0},
		new double []{0,0,0,0,0,0,0,1}
};

//H is the matrix that projects down to the observation.
double [][] H = new double [][] {
		new double [] {1, 0, 0, 0, 0, 0, 0, 0},
		new double [] {0, 1, 0, 0, 0, 0, 0, 0}
};


RealJoint fz = new RealJoint(2);
RealJoint fv = new RealJoint(2);
RealJoint fznonoise = new RealJoint(2);
RealJoint fx = new RealJoint(8);
RealJoint fxnext = new RealJoint(8);

FactorGraph fg = new FactorGraph();
fg.addFactor(new NopFactorFunction("constmult"),fznonoise,H,fx);
fg.addFactor(new NopFactorFunction("add"),fz,fv,fznonoise);
fg.addFactor(new NopFactorFunction("constmult"),fxnext,F,fx);
\end{lstlisting}


\fi


\subpara{Rolled up Graphs and Multivariate Gaussians}

Rolled up graphs can be used with Multivariate Gaussians.  This is useful for creating Kalman filters.  The only difference between Multivariate Gaussian rolled up graphs and other rolled up graphs is the data source type.  See the example code in demo/16\_KalmanFilter/run.m for an example of how this is used.


\subsubsection{Particle BP Solver}

Use of the particle BP solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'ParticleBP';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.setSolver(new com.analog.lyric.dimple.solvers.particleBP.Solver());
\end{lstlisting}
\fi

\para{Methods}

The following sections list the solver-specific methods for the Particle BP solver (MATLAB versions).

\subpara{Graph Methods}

\ifmatlab
\begin{lstlisting}
graph.Solver.setNumParticles(numParticles);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setNumParticles(numParticles);
\end{lstlisting}
\fi

For each variable in the graph, sets the number of particles per variable. This is set globally for all variables in the graph as an alternative to setting this for all variables separately.

\ifmatlab
\begin{lstlisting}
graph.Solver.setResamplingUpdatesPerParticle(updatesPerParticle);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setResamplingUpdatesPerParticle(updatesPerParticle);
\end{lstlisting}
\fi

For each variable in the graph, sets the number of updates per particle to perform each time the particle is resampled. This is set globally for all variables in the graph as an alternative to setting this for all variables separately.

\ifmatlab
\begin{lstlisting}
graph.Solver.setNumIterationsBetweenResampling(numIterationsBetweenResampling);
graph.Solver.getNumIterationsBetweenResampling();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.setSolver().setNumIterationsBetweenResampling(numIterationsBetweenResampling);
graph.setSolver().getNumIterationsBetweenResampling();
\end{lstlisting}
\fi

Set/get the number of iterations between re-sampling all of the variables in the graph (default is 1, meaning resample between every iteration).

\ifmatlab
\begin{lstlisting}
graph.Solver.setInitialTemperature(initialTemperature);
graph.Solver.getInitialTemperature();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setInitialTemperature(initialTemperature);
graph.getSolver().getInitialTemperature();
\end{lstlisting}
\fi


Set/get the initial temperature when using tempering. Note that setting the initial temperature automatically enables the use of tempering if it had not been enabled already.

\ifmatlab
\begin{lstlisting}
graph.Solver.setTemperingHalfLifeInIterations();
graph.Solver.getTemperingHalfLifeInIterations();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setTemperingHalfLifeInIterations();
graph.getSolver().getTemperingHalfLifeInIterations();
\end{lstlisting}
\fi

Set/get the tempering half-lifeÑthe number of iterations for the temperature to decrease by half. Note that setting the tempering half-life automatically enables the use of tempering if it had not been enabled already.

\ifmatlab
\begin{lstlisting}
graph.Solver.enableTempering();
graph.Solver.disableTempering();
graph.Solver.isTemperingEnabled();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().enableTempering();
graph.getSolver().disableTempering();
graph.getSolver().isTemperingEnabled();
\end{lstlisting}
\fi

Enable or disable the use of tempering, or determine if tempering is in use.

\ifmatlab
\begin{lstlisting}
graph.Solver.setTemperature(T);
graph.Solver.getTemperature();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setTemperature(T);
graph.getSolver().getTemperature();
\end{lstlisting}
\fi

Set/get the current temperature. Setting the current temperature overrides the current annealing temperature.

\ifmatlab
\begin{lstlisting}
graph.Solver.setSeed(seed);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setSeed(seed);
\end{lstlisting}
\fi

Set the random seed used for re-sampling. Setting the seed allows repeatable execution of the solver.

\subpara{Variable Methods}

The Particle BP solver supports both discrete and real variables. For discrete variables, the solver uses sum-product BP as normal, and all of the corresponding methods for the sum-product solver may be used for discrete variables. For real variables, several solver-specific methods are defined, as follows.

\subpara{Real-Variable-Specific Methods}
\label{sec:ParticleBPRealVariableSpecificMethods}

\ifmatlab
\begin{lstlisting}
variable.Solver.setNumParticles(numParticles);
variable.Solver.getNumParticles();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setNumParticles(numParticles);
variable.getSolver().getNumParticles();
\end{lstlisting}
\fi

Set/get the number of particles to represent this variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.setResamplingUpdatesPerParticle(updatesPerParticle);
variable.Solver.getResamplingUpdatesPerParticle();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setResamplingUpdatesPerParticle(updatesPerParticle);
variable.getSolver().getResamplingUpdatesPerParticle();
\end{lstlisting}
\fi


Set/get the number of updates per particle to perform each time the particle is resampled.

\ifmatlab
\begin{lstlisting}
variable.Solver.setProposalStandardDeviation(stdDev);
variable.Solver.getProposalStandardDeviation();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setProposalStandardDeviation(stdDev);
variable.getSolver().getProposalStandardDeviation();
\end{lstlisting}
\fi


Set/get the standard deviation for a Gaussian proposal distribution (the default is 1).

\ifmatlab
\begin{lstlisting}
variable.Solver.setInitialParticleRange(min, max);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setInitialParticleRange(min, max);
\end{lstlisting}
\fi

Set the range over which the initial particle values will be defined. The initial particle values are uniformly spaced between the min and max values specified. If the range is specified using this method, it overrides any other initial value. Otherwise, if a finite domain has been specified, the initial particle values are uniformly spaced between the lower and upper bound of the domain. Otherwise, all particles are initially set to zero.

\ifmatlab
\begin{lstlisting}
variable.Solver.getParticleValues();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getParticleValues();
\end{lstlisting}
\fi

Returns the current set of particle values associated with the variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getBelief(valueSet);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getBelief(valueSet);
\end{lstlisting}
\fi

Given a set of values in the domain of the variable, returns the belief evaluated at these points. The result is normalized relative to the set of points requested so that the sum over the set of returned beliefs is 1.

NOTE: the generic variable method Belief (or getBeliefs() with no arguments) operates similarly to the discrete-variable case, but the belief values returned are those at the current set of particle values. Note that this representation does not represent a set of weighted particles. That is, the particle positions are distributed approximately by the belief and the belief values represent the belief. It remains to be see if this should be the representation of belief that is used, or if an alternative representation would be better. The alternative solver-specific getBelief(valueSet) method allows getting the beliefs on a user-specified set of values, which may be uniform, and would not have this unusual interpretation.



\subsubsection{LP Solver}
\label{sec:LPSolver}

\ifmatlab
Use of the linear programming (LP) solver is specified by calling:

\begin{lstlisting}
fg.Solver = 'LP';
\end{lstlisting}

The LP solver transforms a factor graph MAP estimation problem into an equivalent linear program, which is solved using a linear programming software package. The solver can either be a linear programming solver (in which case the MAP is estimated using an LP relaxation, with no guarantees of correctness), or by an integer linear programming (ILP) solver, in which case the solution is guaranteed to be the MAP. 

The choice of the LP solver package used to solve the problem is specified by calling:
\begin{lstlisting}
fg.Solver.setMatlabLPSolver(solvername);
\end{lstlisting}
where solvername is a string containing the solver name. The choices for the string solvername are `matlab', `glpk', `glpkIP', `gurobi', and `gurobiIP'. The `matlab', `glpk', and `gurobi' solvers are linear programming solvers, while `glpkIP' and `gurobiIP' are ILP solvers.

Using the matlab LP solver requires the the MATLAB Optimization Toolbox; using `glpk' or `glpkIP' requires glpkmex to be in the matlab path, and `gurobi' and `gurobiIP' require the gurobi matlab interface to be in the matlab path.\footnote{GLPK and Gurobi are not included in dimple}

The LP solver supports only discrete variables.

In the current version of Dimple (version 0.3), there is no support for rolled-up graphs when using the LP solver.

There are currently no solver-specific methods for the LP solver.

\fi

\ifjava
The LP Solver is not currently supported from java.
\fi
