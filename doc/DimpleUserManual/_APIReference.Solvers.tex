\subsection{Solvers}
\label{sec:SolversAPI}

\subsubsection{Solver-Specific Methods}

Each solver supports a series of solver-specific methods, which are described in the following sections.  Solver-specific methods may be available for various objects: a factor-graph, variable, or factor.  In each case, to call a solver-specific method, the method is applied to the solver object, returned by the Solver property.  For example:

\ifmatlab
\begin{lstlisting}
factorGraph.Solver.solverSpecificMethod(arguments);
\end{lstlisting}

\begin{lstlisting}
variable.Solver.solverSpecificMethod(arguments);
\end{lstlisting}

\begin{lstlisting}
factor.Solver.solverSpecificMethod(arguments);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
factorGraph.getSolver().solverSpecificMethod(arguments);
\end{lstlisting}

\begin{lstlisting}
variable.getSolver().solverSpecificMethod(arguments);
\end{lstlisting}

\begin{lstlisting}
factor.getSolver().solverSpecificMethod(arguments);
\end{lstlisting}
\fi


Some solver-specific methods return results, while others do not.  Some solver-specific methods require arguments, while others do not.  \ifmatlab If no arguments are needed, the parentheses are optional. \fi

\ifmatlab

In some cases it is convenient to call solver-specific methods on each element in an array of objects.  Utility methods are provided for this purpose.  Specifically, to call a solver-specific method that has no return value:
\begin{lstlisting}
objectArray.invokeSolverSpecificMethod('methodName', arguments);
\end{lstlisting}

In this case, 'methodName' is a text string with the name of the solver-specific method, and arguments is an optional comma-separated list of arguments to that method.

To call a solver specific method that has a return value:
\begin{lstlisting}
returnArray = objectArray.invokeSolverSpecificMethodWithReturnValue('methodName', arguments);
\end{lstlisting}

In this case, returnArray is a cell-array of the return values of the method, with dimensions equal to the dimensions of the object array.

\fi

\subsubsection{Common Methods}

\para{useMultithreading}

Users can turn on and off multithreading with the useMultithreading method:

\ifmatlab
\begin{itemize}
\item fg.Solver.useMultithreading(true);
\item m = fg.Solver.useMultithreading();
\end{itemize}
\fi

\ifjava
\begin{itemize}
\item fg.getSolver().useMultithreading(true);
\item m = fg.getSolver().useMultithreading();
\end{itemize}
\fi

\para{getMultithreadingManager}

Dimple users can retrieve a MultithreadingManager on which to perform additional actions.

\ifmatlab
\begin{lstlisting}
fg.Solver.getMultithreadingManager()
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.getSolver().getMultithreadingManager()
\end{lstlisting}
\fi

Users can configure both the multithreading mode and the number of workers using the MultithreadingManager.

\subparagraph{Multithreading Modes}

Dimple provides various multithreading algorithms that have different speed advantages depending on the size of the user's graph and FactorTables.  In the future Dimple should be modified to automatically detect the best threading algorithm.  Currently, however, it defaults to the "Phase" multithreading mode and requires the user manually set the mode to change this.  For a given graph, users can try both modes and see which is faster.

The currently supported multithreading modes are:

\begin{itemize}
\item Phase - Divides the schedule into "phases" where each phase contains schedule entries that are entirely independent of one another.  These phases are then easy to parallelize.  
\item SingleQueue - Uses a single queue and a dependency graph to pull off work for each thread on the fly.  
\end{itemize}

The following methods can be used for getting and setting modes:


\ifmatlab

\begin{itemize}
\item fg.Solver.getMultithreadingManager().getModes() - Returns a Java array of enums specifying the valid modes.
\item fg.Solver.getMultithreadingManager().setMode(ModeName) - Allows users to set the mode by string.  Currently "Phase" or "SingleQueue" will work.
\item fg.Solver.getMultithreadingManager().setMode(enum) - Allows users to set the mode by the enums returned by the getModes method.
\end{itemize}

\fi

\ifjava
\begin{itemize}
\item fg.getSolver().getMultithreadingManager().getModes() - Returns an array of enums specifying the valid modes.
\item fg.getSolver().getMultithreadingManager().setMode(ModeName) - Allows users to set the mode by string.  Currently "Phase" or "SingleQueue" will work.
\item fg.getSolver().getMultithreadingManager().setMode(enum) - Allows users to set the mode by the enums returned by the getModes method or with MultithreadingMode.<PhaseName>.
\end{itemize}
\fi

\subparagraph{Setting Number of Threads and Workers}

Dimple provides a ThreadingPool as a singleton for multithreading.  It sets the number of threads in this pool to the number of virtual cores in the user's machine by default.  Users can override this default value.  In addition, Dimple allows users to specify the number of "workers" for a given FactorGraph.  This "NumWorkers" is also set to the number of virtual cores on the user's machine by default.  Whereas NumThreads specifies how many threads are in the threadPool, NumWorkers specifies how work is divided up across the graph.  These workers are run by the thread pool.  Best performance is achieved when NumWorkers and NumThreads are the same.  However, NumThreads is global and shared by all graphs where NumWorkers is specific to a given FactorGraph.

The following methods can be used to change number of workers:

\ifjava
\begin{itemize}
\item fg.getSolver().getMultithreadingManager().getNumWorkers()
\item fg.getSolver().getMultithreadingManager().setNumWorkers(num)
\item fg.getSolver().getMultithreadingManager().setNumWorkersToDefault()
\end{itemize}
\fi

\ifmatlab
\begin{itemize}
\item fg.Solver.getMultithreadingManager().getNumWorkers()
\item fg.Solver.getMultithreadingManager().setNumWorkers(num)
\item fg.Solver.getMultithreadingManager().setNumWorkersToDefault()
\end{itemize}
\fi

The following global methods can be used to set the number of threads in the ThreadPool

\ifmatlab
\begin{itemize}
\item getDimpleNumThreads()
\item setDimpleNumThreads(numThreads)
\item setDimpleNumThreadsToDefault()
\end{itemize}
\fi

\ifjava
\begin{itemize}
\item ThreadPool.getNumThreads()
\item ThreadPool.setNumThreads(numThreads)
\item ThreadPool.setNumThreadsToDefault()
\end{itemize}
\fi


\subsubsection{Sum-Product Solver}
\label{sec:SumProductSolver}

Use of the sum-product solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'SumProduct';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.setSolverFactory(new com.analog.lyric.dimple.solvers.sumproduct.Solver());
\end{lstlisting}
\fi

If no solver is specified, the SumProduct solver is used by default.

The SumProduct solver supports both discrete and continuous variables.  The SumProduct solver uses the sum-product form of belief propagation to perform inference on a graph.  For discrete variables, each message to or from a factor is in the form of a vector of length equal to the domain size of the variable.  For continuous variables, messages are represented using a Gaussian parameterization.  In some cases, this is an approximation to the exact message.  For Real variables, a message is in the form of a pair of values representing the mean and variance of the corresponding Normal distribution.  For Complex and RealJoint variables, a message is in the form of a vector and matrix, representing the mean and covariance of the corresponding multivariate Normal distribution.

While the Gaussian representation of messages for continuous variables is sometimes and approximation, there are some specific built-in factors for which exact Gaussian messages are computed.  This can be done when a factor preserves the Gaussian form of the distribution on each edge.  The following table is a list of such lists built-in factors.  See section~\ref{sec:builtInFactors} for more information on built-in factors.

\begin{longtable} {p{4.0cm} p{3.0cm} p{7.0cm}}
Built-in Factor & Variable Types &  Notes \\
\hline
\endhead
Sum & Real & All connected variables must be Real.  \\
Subtract & Real & All connected variables must be Real. \\
Negate & Real & All connected variables must be Real. \\
ComplexSum & Complex & All connected variables must be Complex. \\
ComplexSubtract & Complex & All connected variables must be Complex. \\
ComplexNegate & Complex & All connected variables must be Complex. \\
RealJointSum & RealJoint & All connected variables must be RealJoint of the same dimension. \\
RealJointSubtract & RealJoint & All connected variables must be RealJoint of the same dimension. \\
RealJointNegate & RealJoint & All connected variables must be RealJoint of the same dimension. \\
Product & Real, Constant & Applies only if the product is one Real variable times one scalar constant to produce a Real variable. \\
MatrixRealJoint\newline VectorProduct & RealJoint, \newline Constant & Applies only if the product is one RealJoint variable times a constant matrix to produce a RealJoint variable. \\
linear & Real, Constant & Linear equation.  All connected variables must be Real. \\
\end{longtable}

For factors that are neither discrete-only or listed in the above table, an approximate computation is used in computing messages from such a factor.  This includes any factor that connects to both discrete and continuous variables as well as factors that connect only to continuous variables but do not appear in the list above.  The approximate method is sample based and uses Gibbs sampling to sample from the factor, allowing approximate messages to be computed from the sample statistics.  Several methods described below allow control over the behavior of these sampled factors.

The following sections list the solver-specific methods for the SumProduct solver.

\para{Graph Methods}

\subpara{setDamping}

The SumProduct solver supports damping, in which messages are damped by replacing each message by a weighted sum of the computed message value and the previous value of that message (when the corresponding edge was most-recently updated).

In the current version of Dimple, damping is supported only in discrete variables and factors that connect only to discrete variables\footnote{Support for damping for continuous variables may be added in a future release.}.

The damping parameter sets the weighting value:

\[
\mathrm{message} = \mathrm{computedMessage} \cdot (1 - D) + \mathrm{previousMessage} \cdot D
\]

where $D$ is the damping value.  The set Damping method can be used to set the damping value.

\ifmatlab
\begin{lstlisting}
fg.Solver.setDamping(dampingValue);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
solver.setDamping(dampingValue);
\end{lstlisting}
\fi

The dampingValue argument must be in the range from 0 through 1.  If this method is never called, the default damming value of 0 is used.

\subpara{setSampledFactorSamplesPerUpdate}

Factors connected to continuous variables that do not support exact message computation, instead use a sampled approximation (see section~\ref{sec:SumProductSolver}).  For all such factors in a graph, this method sets the number of samples to generate to form the estimate of each output message.  Note that this sample generation is done separately for each edge of the factor.  The default number of samples used if this method is never called is 1000.

\ifmatlab
\begin{lstlisting}
fg.Solver.setSampledFactorSamplesPerUpdate(samplesPerUpdate);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
solver.setSampledFactorSamplesPerUpdate(samplesPerUpdate);
\end{lstlisting}
\fi


\subpara{getSampledFactorSamplesPerUpdate}

This method retrieves the number of samples per update used for factors connected to continuous variables that use approximate sampled message computation.

\ifmatlab
\begin{lstlisting}
samplesPerUpdate = fg.Solver.getSampledFactorSamplesPerUpdate();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
int samplesPerUpdate = solver.getSampledFactorSamplesPerUpdate();
\end{lstlisting}
\fi


\subpara{setSampledFactorBurnInScansPerUpdate}

For all factors connected to continuous variables that use approximate sampled message computation, this method sets the number of burn-in scans to perform prior to collecting samples used to compute the output messages.  The default number of burn-in samples used if this method is never called is 10.

\ifmatlab
\begin{lstlisting}
fg.Solver.setSampledFactorBurnInScansPerUpdate(burnInScans);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
solver.setSampledFactorBurnInScansPerUpdate(burnInScans);
\end{lstlisting}
\fi


\subpara{getSampledFactorBurnInScansPerUpdate}

This method retrieves the number of burn-in scans per update used for factors connected to continuous variables that use approximate sampled message computation.

\ifmatlab
\begin{lstlisting}
burnInScans = fg.Solver.getSampledFactorBurnInScansPerUpdate();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
int burnInScans = solver.getSampledFactorBurnInScansPerUpdate();
\end{lstlisting}
\fi


\subpara{setSampledFactorScansPerSample}

For all factors connected to continuous variables that use approximate sampled message computation, this method sets the number of scans to perform for each sample used to compute the output messages.  The default number of scans per sample used if this method is never called is 1.  Setting this to a value larger than one allows thinning of the sampled output.

\ifmatlab
\begin{lstlisting}
fg.Solver.setSampledFactorScansPerSample(scansPerSample);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
solver.setSampledFactorScansPerSample(scansPerSample);
\end{lstlisting}
\fi

\subpara{getSampledFactorScansPerSample}

This method retrieves the scans per sample used for factors connected to continuous variables that use approximate sampled message computation.

\ifmatlab
\begin{lstlisting}
scansPerSample = fg.Solver.getSampledFactorScansPerSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
int scansPerSample = solver.getSampledFactorScansPerSample();
\end{lstlisting}
\fi


\para{Factor Methods}

\subpara{setK}

The SumProduct solver supports the k-best variant of the sum-product algorithm for discrete variables and factors connected only to discrete variables.  Users can set a K value on each factor:

\ifmatlab
\begin{lstlisting}
factor.Solver.setK(K);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
STableFactor sfactor = (STableFactor)f.getSolver();
sfactor.setK(K);
\end{lstlisting}
\fi


The solver will only use the K best values for each variable when calculating output messages on a factor node.

IMPORTANT: k-best and damping are not compatible with each other\footnote{This restriction may be removed in a future version of Dimple.}.





\subsubsection{Min-Sum Solver}

Use of the MinSum solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'MinSum';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.setSolver(new com.analog.lyric.dimple.solvers.minsum.Solver());
\end{lstlisting}
\fi

The MinSum solver supports only discrete variables.

The following sections list the solver-specific methods for the MinSum solver.

\para{Graph Methods}

\subpara{setDamping}

The MinSum solver supports damping, in which messages are damped by replacing each message by a weighted sum of the computed message value and the previous value of that message (when the corresponding edge was most-recently updated).  The damping parameter sets the weighting value:

\[
\mathrm{message} = \mathrm{computedMessage} \cdot (1 - D) + \mathrm{previousMessage} \cdot D
\]

where $D$ is the damping value.  The set Damping method can be used to set the damping value.

\ifmatlab
\begin{lstlisting}
fg.Solver.setDamping(dampingValue);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
SFactorGraph solver = ((SFactorGraph)fg.getSolver());
solver.setDamping(dampingValue);
\end{lstlisting}
\fi


The dampingValue argument must be in the range from 0 through 1.  If this method is never called, the default damming value of 0 is used.

Note that damping in the MinSum solver is done on messages in the log-domain, which has slightly different behavior than damping in the probability domain, as is done in the SumProduct solver.


\para{Factor Methods}

\subpara{setK}

The SumProduct solver supports the k-best variant of the sum-product algorithm.  Users can set a K value on each factor:

\ifmatlab
\begin{lstlisting}
factor.Solver.setK(K);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
STableFactor sfactor = (STableFactor)f.getSolver();
sfactor.setK(K);
\end{lstlisting}
\fi

The solver will only use the K best values for each variable when calculating output messages on a factor node.

IMPORTANT: k-best and damping are not compatible with each other\footnote{This restriction may be removed in a future version of Dimple.}.


\subsubsection{Gibbs Solver}
\label{sec:GibbsSolverAPI}

Use of the Gibbs solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'Gibbs';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.setSolver(new com.analog.lyric.dimple.solvers.gibbs.Solver());
\end{lstlisting}
\fi

The Gibbs solver supports both discrete and continuous variables.

This solver performs Gibbs sampling on a factor graph.  It supports a variety of output information on the sampled graph, including the best joint sample (lowest energy), marginals of each variable (discrete variables only), and a full set of samples for a user-selected set of variables.  The solver supports both sequential and randomized scan, and it supports tempering with an exponential tempering schedule.

The Gibbs solver supports several user selectable generic samplers (those that don't require specific conjugacy relationships).  The following table lists the available generic samplers, and the variable types supported by each.

\begin{longtable} {l l p{8.0cm}}
Sampler & Variable Type &  Description \\
\hline
\endhead
CDFSampler & Discrete\footnote{In this table, Discrete support implies any of the discrete variable types, including Discrete and Bit.} & Samples from the full conditional distribution of the variable.  This is the default sampler for discrete variables. \\
SliceSampler & Real\footnote{In this table, Real support implies any of the continuous variable data types, including Real, Complex, and RealJoint.} & Slice sampler using the doubling procedure.  See Neal, Slice Sampling (2000).  This is the default sampler for real variables. \\
MHSampler & Discrete \& Real & Metropolis-Hastings sampler.  For discrete variables, the default proposal kernel is uniform over values other than the current value.  For real variables, the default proposal kernel is Normal with standard deviation 1 (the standard deviation is user settable).  Alternate proposal kernels are also available (see below). \\
SuwaTodoSampler & Discrete & Suwa-Todo sampler.  See Suwa, Todo, Markov Chain Monte Carlo Method without Detailed Balance (2010). \\
\end{longtable}


In cases where the factors of the graph support a conjugate distribution, the solver will automatically determine this and use the appropriate conjugate sampler.  The following table lists the supported conjugate samplers and the corresponding factors that support them.  The corresponding sampler will be used for a given variable if all of the edges connected to that variable support the same sampler\footnote{Additionally, for the conjugate sampler to be used, the domain of the variable must not be bounded to a range smaller than the natural range of the corresponding distribution.}.

\begin{longtable} {l p{7.1cm} p{2.5cm}}
Sampler & Built-in Factor & Edge \\
\hline
\endhead
BetaSampler & Beta & value \\
 & Binomial & $\rho$ \\
DirichletSampler & Dirichlet & value \\
 & Categorical & $\alpha$ \\
 & DiscreteTransition & $\alpha$ \\
GammaSampler & Gamma & value, $\beta$ \\
 & NegativeExpGamma & $\beta$ \\
 & Normal & $\tau$ \\
 & LogNormal & $\tau$ \\
 & CategoricalUnnormalizedParameters & $\alpha$ \\
 & DiscreteTransitionUnnormalizedParameters & $\alpha$ \\
NegativeExpGammaSampler & NegativeExpGamma & value \\
 & CategoricalEnergyParameters & $\alpha$ \\ 
 & DiscreteTransitionEnergyParameters & $\alpha$ \\ 
NormalSampler & Normal & value, $\mu$ \\
 & LogNormal & $\mu$ \\
\end{longtable}

Additionally, conjugate sampling is supported across a subset of applicable deterministic functions.  In the current version of Dimple, this includes the following factors:

\begin{longtable} {l p{2cm} p{9cm}}
Factor Function & Edges & Condition \\
\hline
\endhead
Multiplexer & in, out & If any of the \emph{in} variables would support the same conjugate sampler as the \emph{out} variable, then those \emph{in} variables will use conjugate sampling. \\
\end{longtable}


The Gibbs solver automatically performs block-Gibbs updates for variables that are deterministically related.  The Gibbs solver automatically detects deterministic relationships associated with built-in deterministic factor functions (see section~\ref{sec:builtInFactors} for a list of these functions).  

\ifmatlab
For user-defined factors specified by MATLAB factor functions or factor tables, the Gibbs solver will detect if they are deterministic functions as along as the factor is marked as the directed outputs are indicated using the DirectedTo property, as described in section~\ref{sec:Factor.DirectedTo}.
\fi

\ifjava
For user-defined factors specified by factor functions or factor tables, the Gibbs solver will detect if they are deterministic functions as along as the factor is marked as the directed outputs are indicated using the DirectedTo property, as described in section~\ref{sec:Factor.DirectedTo}.
\fi
 

Most Dimple methods work more-or-less as normal when using the Gibbs solver, but in some cases the interpretation is slightly different. For example, the .Belief method for a discrete variable returns an estimate of the belief based on averaging over the sample values.

NOTE: The setNumIterations() method is not supported by the Gibbs solver as the term ``iteration'' is ambiguous in this case. Instead, the method setNumSamples() should be used to set the length of the run. The Solver.iterate() method performs a single-variable update in the case of the Gibbs solver, rather than an entire scan of all variables.

The following sections list the solver-specific methods for the Gibbs solver.

\para{Graph Methods}

The following methods are available on a graph set to use the Gibbs solver:

\ifmatlab
\begin{lstlisting}
graph.Solver.setNumSamples(numSamples);
graph.Solver.getNumSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setNumSamples(numSamples);
graph.getSolver().getNumSamples();
\end{lstlisting}
\fi

Set/get the number of samples to be run when solving the graph (post burn-in).

\ifmatlab
\begin{lstlisting}
graph.Solver.setScansPerSample(scansPerSample);
graph.Solver.getScansPerSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setScansPerSample(scansPerSample);
graph.getSolver().getScansPerSample();
\end{lstlisting}
\fi

Set the number of scans between samples as an alternative means of specifying the sample rate. A scan is an update of the number of variables equal to the total number of variables in the graph.

\ifmatlab
\begin{lstlisting}
graph.Solver.setUpdatesPerSample(updatesPerSample);
graph.Solver.getUpdatesPerSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setUpdatesPerSample(updatesPerSample);
graph.getSolver().getUpdatesPerSample();
\end{lstlisting}
\fi


Set/get the number of single-variable updates between samples.

\ifmatlab
\begin{lstlisting}
graph.Solver.setBurnInScans(burnInScans);
graph.Solver.getBurnInScans();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setBurnInScans(burnInScans);
graph.getSolver().getBurnInScans();
\end{lstlisting}
\fi

Set the number of scans for burn-in as an alternative means of specifying the burn-in period.

\ifmatlab
\begin{lstlisting}
graph.Solver.setBurnInUpdates(burnInUpdates);
graph.Solver.getBurnInUpdates();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setBurnInUpdates(burnInUpdates);
graph.getSolver().getBurnInUpdates();
\end{lstlisting}
\fi

Set/get the number of single-variable updates for the burn-in period prior to collecting samples.

\ifmatlab
\begin{lstlisting}
graph.Solver.setNumRestarts(numRestarts)
graph.Solver.getNumRestarts() 
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setNumRestarts(numRestarts)
graph.getSolver().getNumRestarts() 
\end{lstlisting}
\fi

Set/get the number of random restarts (zero by default, which means run once and don't restart).  For a value greater than zero, the after running the specified number of samples, the solver is restarted with the variable values randomized, and re-run (including burn-in).  The sample values (the best sample value, or all samples, if requested) are extracted across all runs.

Variable initialization (both on the first run and subsequent restarts) is randomized whenever possible.  For a discrete variable, the value is sampled from the Input (uniform if an input is not specified).  For a real variable, if an Input is specified and the Input supports one of the conjugate samplers listed above, that sampler is used to initialize the variable.  If bounds are also specified for the variable domain, the values is truncated to fall within the bounds.  If only bounds are specified (which are finite above and below), then the value is uniformly sampled from within the bounds.  If no finite bounds are specified and there is no input, the variable is initialized to zero (or the value specified by setInitialSampleValue) on the initial run, and left at the final value of the previous run on restart.


\ifmatlab
\begin{lstlisting}
graph.Solver.setDefaultDiscreteSampler(samplerName);
graph.Solver.getDefaultDiscreteSampler();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setDefaultDiscreteSampler(samplerName);
graph.getSolver().getDefaultDiscreteSampler();
\end{lstlisting}
\fi

Set/get the default sampler for Discrete and Bit.  The default sampler can be set only to one of the generic samplers listed in the table of generic samplers, above.  The CDFSampler is the default sampler for discrete variables unless overridden by this method.  Note that for a particular variable, the default sampler is used only if the user has not overridden the default for that variable using the variable-specific setSampler method.

\ifmatlab
\begin{lstlisting}
graph.Solver.setDefaultRealSampler(samplerName);
graph.Solver.getDefaultRealSampler();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setDefaultRealSampler(samplerName);
graph.getSolver().getDefaultRealSampler();
\end{lstlisting}
\fi

Set/get the default sampler for Real, Complex, and RealJoint variables.  The default sampler can be set only to one of the generic samplers listed in the table of generic samplers, above.  The SliceSampler is the default sampler for real variables unless overridden by this method.  Note that for a particular variable, the default sampler is used only if there is no available conjugate sampler and the user has not overridden the default for that variable using the variable-specific setSampler method.


\ifmatlab
\begin{lstlisting}
graph.Solver.setInitialTemperature(initialTemperature);
graph.Solver.getInitialTemperature();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setInitialTemperature(initialTemperature);
graph.getSolver().getInitialTemperature();
\end{lstlisting}
\fi

Set/get the initial temperature when using tempering. Note that setting the initial temperature automatically enables the use of tempering if it had not been enabled already.

\ifmatlab
\begin{lstlisting}
graph.Solver.setTemperingHalfLifeInSamples();
graph.Solver.getTemperingHalfLifeInSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setTemperingHalfLifeInSamples();
graph.getSolver().getTemperingHalfLifeInSamples();
\end{lstlisting}
\fi


Set/get the tempering half-life.  the number of samples for the temperature to decrease by half. Note that setting the tempering half-life automatically enables the use of tempering if it had not been enabled already.

\ifmatlab
\begin{lstlisting}
graph.Solver.enableTempering();
graph.Solver.disableTempering();
graph.Solver.isTemperingEnabled();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().enableTempering();
graph.getSolver().disableTempering();
graph.getSolver().isTemperingEnabled();
\end{lstlisting}
\fi

Enable or disable the use of tempering, or determine if tempering is in use.

\ifmatlab
\begin{lstlisting}
graph.Solver.setTemperature(T);
graph.Solver.getTemperature();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setTemperature(T);
graph.getSolver().getTemperature();
\end{lstlisting}
\fi

Set/get the current temperature. Setting the current temperature overrides the current annealing temperature.

\ifmatlab
\begin{lstlisting}
graph.Solver.saveAllSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().saveAllSamples();
\end{lstlisting}
\fi

Prior to solving the graph, this method instructs the solver to save all sample values for all variables. Note that this is practical only for relatively small graphs with relatively small number of samples.

\ifmatlab
\begin{lstlisting}
graph.Solver.disableSavingAllSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().disableSavingAllSamples();
\end{lstlisting}
\fi

In case saveAllSamples had previously been called, calling this method disables saving all samples on future runs.

\ifmatlab
\begin{lstlisting}
graph.Solver.saveAllScores();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().saveAllScores();
\end{lstlisting}
\fi

Prior to solving the graph, this method instructs the solver to save the score value (see section~\ref{sec:FactorGraph.Score}) of the graph for each sample.

\ifmatlab
\begin{lstlisting}
graph.Solver.disableSavingAllScores();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().disableSavingAllScores();
\end{lstlisting}
\fi

In case saveAllScores had previously been called, calling this method disables saving all samples on future runs.

\ifmatlab
\begin{lstlisting}
graph.Solver.getAllScores();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().getAllScores();
\end{lstlisting}
\fi

Returns an array including the score value for each sample. This method only returns a non-empty value if .saveAllScores() method had previously been called on the graph.

\ifmatlab
\begin{lstlisting}
graph.Solver.setSeed(seed);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setSeed(seed);
\end{lstlisting}
\fi

Set the random seed used for sampling (and used for random scan, if that schedule is used). Setting the seed allows repeatable execution of the Gibbs solver.

\ifmatlab
\begin{lstlisting}
graph.Solver.getTotalPotential();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().getTotalPotential();
\end{lstlisting}
\fi

After running the solver, returns the total potential (score) over all factors of the graph (including input priors on variables) given the most recent sample values.

\ifmatlab
\begin{lstlisting}
graph.Solver.sample(numSamples)
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().sample(numSamples)
\end{lstlisting}
\fi

This method runs a specified number of samples without re-initializing, burn-in, or random-restarts (this is distinct from iterate(), which runs a specified number of single-variable updates).  Before running this method for the first time, the graph must be initialized using the initialize() method.

\ifmatlab
\begin{lstlisting}
graph.Solver.burnIn()
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().burnIn()
\end{lstlisting}
\fi

Run the burn-in samples independently of using solve (which automatically runs the burn-in samples).  This may be run before using sample() or iterate().

\para{Variable Methods}

\ifmatlab
\begin{lstlisting}
variable.Solver.getCurrentSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getCurrentSample();
\end{lstlisting}
\fi

Returns the current sample value for a variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getAllSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getAllSamples();
\end{lstlisting}
\fi

Returns an array including all sample values seen so far for a variable. Over multiple variables, samples with the same index correspond to the same joint sample value. This method only returns a non-empty value if .saveAllSamples() method had previously been called on the graph or for the variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getBestSample();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getBestSample();
\end{lstlisting}
\fi


Returns the value of the best sample value seen so far, where best is defined as the sample with the minimum total potential over the graph (sum of -log of the factor values and input priors).  When getting the best sample from multiple variables, they all correspond to the same sample in time, thus should be a valid sample from the joint distribution.

\ifmatlab
\begin{lstlisting}
variable.Solver.saveAllSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().saveAllSamples();
\end{lstlisting}
\fi

Prior to solving the graph, this method instructs the solver to save all sample values for this variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.disableSavingAllSamples();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().disableSavingAllSamples();
\end{lstlisting}
\fi

In case saveAllSamples had previously been called, calling this method disables saving all samples for this variable on future runs.

\ifmatlab
\begin{lstlisting}
variable.Solver.setInitialSampleValue(initialSampleValue)
variable.Solver.getInitialSampleValue()
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setInitialSampleValue(initialSampleValue)
variable.getSolver().getInitialSampleValue()
\end{lstlisting}
\fi

Set/get the initial sample value to be used as the starting value for this variable.  This value is used only on the first run (not subsequent restarts).  Setting this value overrides any randomization of the starting value on the first run.


\ifmatlab
\begin{lstlisting}
variable.Solver.setSampler(samplerName);
variable.Solver.getSampler();
variable.Solver.getSamplerName();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setSampler(samplerName);
variable.getSolver().getSampler();
variable.getSolver().getSamplerName();
\end{lstlisting}
\fi

Set/get the sampler to be used for this variable.  Setting the sampler for a given variable overrides the default sampler for the given variable type, and also overrides any conjugate sampler that might otherwise be used.  Using this method the sampler may be set only to one of the generic samplers appropriate for the given variable type.

The getSampler method returns the sampler object, while the getSamplerName method returns a string indicating the name of the sampler being used for this variable.  Automatic assignment of a conjugate sampler is done at graph initialization time, so in order to determine what sampler will actually be used, these methods must be called either after a call to the graph initialize method, or after running the solver.


\para{Discrete-Variable-Specific Methods}

The following methods apply to Discrete or Bit variables when using the Gibbs solver.

\ifmatlab
\begin{lstlisting}
variable.Solver.getSampleIndex;
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getSampleIndex();
\end{lstlisting}
\fi

Returns the index of the current sample for a variable, where the index refers to the index into the domain of the variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getAllSampleIndices;
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getAllSampleIndices();
\end{lstlisting}
\fi

Returns an array including the indices of all samples seen so far for a variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getBestSampleIndex;
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getBestSampleIndex();
\end{lstlisting}
\fi

Returns the index of the best sample seen so far.


\ifmatlab
\begin{lstlisting}
variable.Solver.setInitialSampleIndex(initialSampleIndex)
variable.Solver.getInitialSampleIndex()
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setInitialSampleIndex(initialSampleIndex)
variable.getSolver().getInitialSampleIndex()
\end{lstlisting}
\fi

Set/get the initial sample index associated with the starting value for this variable.  The value associated with this index is used only on the first run (not subsequent restarts).  Setting this index overrides any randomization of the starting value on the first run.


\para{Sampler-Specific Methods}

Some of the generic samplers supported by the Gibbs solver include user configurable options, described in below.

The SliceSampler supports setting/getting the initial slice width and the maximum number of doublings:

\ifmatlab
\begin{lstlisting}
variable.Solver.getSampler().setInitialSliceWidth(width);
variable.Solver.getSampler().getInitialSliceWidth();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getSampler().setInitialSliceWidth(width);
variable.getSolver().getSampler().getInitialSliceWidth();
\end{lstlisting}
\fi

The above methods set/get the initial slice width to be used by the slice sampler.  The default initial width is 1.  For variables with a natural range that is much smaller or much larger than one, it may be beneficial to modify this value.

\ifmatlab
\begin{lstlisting}
variable.Solver.getSampler().setMaximumDoublings(numDoublings);
variable.Solver.getSampler().getMaximumDoublings();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getSampler().setMaximumDoublings(numDoublings);
variable.getSolver().getSampler().getMaximumDoublings();
\end{lstlisting}
\fi

The above methods set/get the maximum number of doublings used by the slice sampler.  The default value is 10.

The MHSampler supports setting/getting the proposal kernel:

\ifmatlab
\begin{lstlisting}
variable.Solver.getSampler().setProposalKernel(proposalKernelName);
variable.Solver.getSampler().setProposalKernel(proposalKernelObject);
variable.Solver.getSampler().getProposalKernel();
variable.Solver.getSampler().getProposalKernelName();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getSampler().setProposalKernel(proposalKernelName);
variable.getSolver().getSampler().setProposalKernel(proposalKernelObject);
variable.getSolver().getSampler().getProposalKernel();
variable.getSolver().getSampler().getProposalKernelName();
\end{lstlisting}
\fi

The setProposalKernel method allows setting the proposal kernel either by name or by specifying an existing proposal kernel object.  For discrete variables, Dimple currently supports only one proposal kernel: UniformDiscreteProposalKernel, though a user may create new proposal kernel Java classes.  For real variables, Dimple currently supports: NormalProposalKernel and CircularNormalProposalKernel.  The default kernel for real variables is NormalProposalKernel.

The method getProposalKernel returns the proposal kernel object, while getProposalKernelName returns a string indicating the name of the current proposal kernel.

The NormalProposalKernel by default makes proposals from a Normal distribution with standard deviation 1.  The standard deviation is settable using:

\ifmatlab
\begin{lstlisting}
variable.Solver.getSampler().getProposalKernel().setStandardDeviation(std);
variable.Solver.getSampler().getProposalKernel().getStandardDeviation();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getSampler().getProposalKernel().setStandardDeviation(std);
variable.getSolver().getSampler().getProposalKernel().getStandardDeviation();
\end{lstlisting}
\fi

The above methods set/get the standard deviation for a NormalProposalKernel.  The default standard deviation is 1.

The CircularNormalProposalKernel makes proposals from a Normal distribution on a circularly wrapping range of the real line.  For example, setting the bounds of the range to $-\pi$ and $\pi$ would create proposals representing angles on a circle.  The CircularNormalProposalKernel has settable parameters that include the standard deviation as well as the lower and upper bounds of the circular range.

\ifmatlab
\begin{lstlisting}
variable.Solver.getSampler().getProposalKernel().setStandardDeviation(std);
variable.Solver.getSampler().getProposalKernel().getStandardDeviation();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getSampler().getProposalKernel().setStandardDeviation(std);
variable.getSolver().getSampler().getProposalKernel().getStandardDeviation();
\end{lstlisting}
\fi

The above methods set/get the standard deviation for a CircularNormalProposalKernel.  The default standard deviation is 1.

\ifmatlab
\begin{lstlisting}
variable.Solver.getSampler().getProposalKernel().setCircularBounds(lower, upper);
variable.Solver.getSampler().getProposalKernel().getLowerBound();
variable.Solver.getSampler().getProposalKernel().getUpperBound();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getSampler().getProposalKernel().setCircularBounds(lower, upper);
variable.getSolver().getSampler().getProposalKernel().getLowerBound();
variable.getSolver().getSampler().getProposalKernel().getUpperBound();
\end{lstlisting}
\fi

The above methods set/get the lower and upper bounds of the circular range of values.  The default lower and upper bounds are $-\pi$ and $\pi$, respectively.


\para{Factor Methods}

\ifmatlab
\begin{lstlisting}
factor.Solver.getPotential();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
factor.getSolver().getPotential();
\end{lstlisting}
\fi

Returns the potential value of a factor given the current values of its connected variables.

\ifmatlab
\begin{lstlisting}
factor.Solver.getPotential(values);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
factor.getSolver().getPotential(values);
\end{lstlisting}
\fi

Get the potential value of a factor given the variable values specified by the argument vector. The argument must be a vector with length equal to the number of connected variables. For a table-factor (connected exclusively to discrete variables), each value corresponds the index into the domain list for that variable (not the value of the variable itself). For a real-factor (connected to one or more real variables), each value corresponds to the value of the variable.

\para{Schedulers}

The built-in schedulers designed for belief propagation are not appropriate for the Gibbs solver.  Instead, there are two built-in schedulers specifically for the Gibbs solver:

\begin{itemize}
\item GibbsSequentialScanScheduler
\item GibbsRandomScanScheduler
\end{itemize}

The GibbsSequentialScanScheduler chooses the next variable for updating in a fixed order. It updates all variables in the graph, completing an entire scan, before repeating the same fixed order. (In Gibbs literature this seems to be known as a sequential-scan, systematic-scan, or fixed-scan schedule.)

The GibbsRandomScanScheduler randomly selects a variable for each update (with replacement).

The default scheduler when using the Gibbs solver is the GibbsSequentialScanScheduler, which is used if no scheduler is explicitly specified.

The user may specify a custom schedule when using the Gibbs solver.  In this case, the schedule should include only Variable node updates (not specific edges), and no Factor updates (any Factor updates specified will be ignored).

To explicitly specify a scheduler, use the Scheduler or Schedule property of the FactorGraph (see sections~\ref{sec:FactorGraph.Scheduler} and~\ref{sec:FactorGraph.Schedule}).


\subsubsection{Particle BP Solver}

Use of the particle BP solver is specified by calling:

\ifmatlab
\begin{lstlisting}
fg.Solver = 'ParticleBP';
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
fg.setSolver(new com.analog.lyric.dimple.solvers.particleBP.Solver());
\end{lstlisting}
\fi

The following sections list the solver-specific methods for the ParticleBP solver.

\para{Graph Methods}

\ifmatlab
\begin{lstlisting}
graph.Solver.setNumParticles(numParticles);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setNumParticles(numParticles);
\end{lstlisting}
\fi

For each variable in the graph, sets the number of particles per variable. This is set globally for all variables in the graph as an alternative to setting this for all variables separately.

\ifmatlab
\begin{lstlisting}
graph.Solver.setResamplingUpdatesPerParticle(updatesPerParticle);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setResamplingUpdatesPerParticle(updatesPerParticle);
\end{lstlisting}
\fi

For each variable in the graph, sets the number of updates per particle to perform each time the particle is resampled. This is set globally for all variables in the graph as an alternative to setting this for all variables separately.

\ifmatlab
\begin{lstlisting}
graph.Solver.setNumIterationsBetweenResampling(numIterationsBetweenResampling);
graph.Solver.getNumIterationsBetweenResampling();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.setSolver().setNumIterationsBetweenResampling(numIterationsBetweenResampling);
graph.setSolver().getNumIterationsBetweenResampling();
\end{lstlisting}
\fi

Set/get the number of iterations between re-sampling all of the variables in the graph (default is 1, meaning resample between every iteration).

\ifmatlab
\begin{lstlisting}
graph.Solver.setInitialTemperature(initialTemperature);
graph.Solver.getInitialTemperature();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setInitialTemperature(initialTemperature);
graph.getSolver().getInitialTemperature();
\end{lstlisting}
\fi


Set/get the initial temperature when using tempering. Note that setting the initial temperature automatically enables the use of tempering if it had not been enabled already.

\ifmatlab
\begin{lstlisting}
graph.Solver.setTemperingHalfLifeInIterations();
graph.Solver.getTemperingHalfLifeInIterations();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setTemperingHalfLifeInIterations();
graph.getSolver().getTemperingHalfLifeInIterations();
\end{lstlisting}
\fi

Set/get the tempering half-lifeï¿½the number of iterations for the temperature to decrease by half. Note that setting the tempering half-life automatically enables the use of tempering if it had not been enabled already.

\ifmatlab
\begin{lstlisting}
graph.Solver.enableTempering();
graph.Solver.disableTempering();
graph.Solver.isTemperingEnabled();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().enableTempering();
graph.getSolver().disableTempering();
graph.getSolver().isTemperingEnabled();
\end{lstlisting}
\fi

Enable or disable the use of tempering, or determine if tempering is in use.

\ifmatlab
\begin{lstlisting}
graph.Solver.setTemperature(T);
graph.Solver.getTemperature();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setTemperature(T);
graph.getSolver().getTemperature();
\end{lstlisting}
\fi

Set/get the current temperature. Setting the current temperature overrides the current annealing temperature.

\ifmatlab
\begin{lstlisting}
graph.Solver.setSeed(seed);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
graph.getSolver().setSeed(seed);
\end{lstlisting}
\fi

Set the random seed used for re-sampling. Setting the seed allows repeatable execution of the solver.

\para{Variable Methods}

The Particle BP solver supports both discrete and real variables. For discrete variables, the solver uses sum-product BP as normal, and all of the corresponding methods for the sum-product solver may be used for discrete variables. For real variables, several solver-specific methods are defined, as follows.

\para{Real-Variable-Specific Methods}
\label{sec:ParticleBPRealVariableSpecificMethods}

\ifmatlab
\begin{lstlisting}
variable.Solver.setNumParticles(numParticles);
variable.Solver.getNumParticles();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setNumParticles(numParticles);
variable.getSolver().getNumParticles();
\end{lstlisting}
\fi

Set/get the number of particles to represent this variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.setResamplingUpdatesPerParticle(updatesPerParticle);
variable.Solver.getResamplingUpdatesPerParticle();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setResamplingUpdatesPerParticle(updatesPerParticle);
variable.getSolver().getResamplingUpdatesPerParticle();
\end{lstlisting}
\fi


Set/get the number of updates per particle to perform each time the particle is resampled.

\ifmatlab
\begin{lstlisting}
variable.Solver.setProposalStandardDeviation(stdDev);
variable.Solver.getProposalStandardDeviation();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setProposalStandardDeviation(stdDev);
variable.getSolver().getProposalStandardDeviation();
\end{lstlisting}
\fi


Set/get the standard deviation for a Gaussian proposal distribution (the default is 1).

\ifmatlab
\begin{lstlisting}
variable.Solver.setInitialParticleRange(min, max);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().setInitialParticleRange(min, max);
\end{lstlisting}
\fi

Set the range over which the initial particle values will be defined. The initial particle values are uniformly spaced between the min and max values specified. If the range is specified using this method, it overrides any other initial value. Otherwise, if a finite domain has been specified, the initial particle values are uniformly spaced between the lower and upper bound of the domain. Otherwise, all particles are initially set to zero.

\ifmatlab
\begin{lstlisting}
variable.Solver.getParticleValues();
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getParticleValues();
\end{lstlisting}
\fi

Returns the current set of particle values associated with the variable.

\ifmatlab
\begin{lstlisting}
variable.Solver.getBelief(valueSet);
\end{lstlisting}
\fi

\ifjava
\begin{lstlisting}
variable.getSolver().getBelief(valueSet);
\end{lstlisting}
\fi

Given a set of values in the domain of the variable, returns the belief evaluated at these points. The result is normalized relative to the set of points requested so that the sum over the set of returned beliefs is 1.

NOTE: the generic variable method Belief (or getBeliefs() with no arguments) operates similarly to the discrete-variable case, but the belief values returned are those at the current set of particle values. Note that this representation does not represent a set of weighted particles. That is, the particle positions are distributed approximately by the belief and the belief values represent the belief. It remains to be see if this should be the representation of belief that is used, or if an alternative representation would be better. The alternative solver-specific getBelief(valueSet) method allows getting the beliefs on a user-specified set of values, which may be uniform, and would not have this unusual interpretation.



\subsubsection{LP Solver}
\label{sec:LPSolver}

\ifmatlab
Use of the linear programming (LP) solver is specified by calling:

\begin{lstlisting}
fg.Solver = 'LP';
\end{lstlisting}

The LP solver transforms a factor graph MAP estimation problem into an equivalent linear program, which is solved using a linear programming software package. The solver can either be a linear programming solver (in which case the MAP is estimated using an LP relaxation, with no guarantees of correctness), or by an integer linear programming (ILP) solver, in which case the solution is guaranteed to be the MAP. 

The choice of the LP solver package used to solve the problem is specified by calling:
\begin{lstlisting}
fg.Solver.setMatlabLPSolver(solvername);
\end{lstlisting}
where solvername is a string containing the solver name. The choices for the string solvername are `matlab', `glpk', `glpkIP', `gurobi', and `gurobiIP'. The `matlab', `glpk', and `gurobi' solvers are linear programming solvers, while `glpkIP' and `gurobiIP' are ILP solvers.

Using the matlab LP solver requires the the MATLAB Optimization Toolbox; using `glpk' or `glpkIP' requires glpkmex to be in the matlab path, and `gurobi' and `gurobiIP' require the gurobi matlab interface to be in the matlab path.\footnote{GLPK and Gurobi are not included in dimple}

The LP solver supports only discrete variables.

In the current version of Dimple (version 0.3), there is no support for rolled-up graphs when using the LP solver.

There are currently no solver-specific methods for the LP solver.

\fi

\ifjava
The LP Solver is not currently supported from java.
\fi
