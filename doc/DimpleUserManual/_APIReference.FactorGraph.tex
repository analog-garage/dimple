\subsection{FactorGraph}

The FactorGraph class represents a single factor graph and contains a collection of all factors associated with that factor graph and all variables that are connected by factors to the graph.

\subsubsection{Constructor}

\begin{lstlisting}
FactorGraph([boundaryVariables])
\end{lstlisting}

For a basic factor graph, the constructor is simply the command FactorGraph with no arguments.

For a nested factor graph (one that may be used as a sub-graph within another graph), the constructor must include a list of the boundary variables of the graph.  When used as a sub-graph, the boundary variables are dummy variables with the same specification as the variables in the outer graph that will ultimately connect to the sub-graph.  A graph defined with boundary variables may alternatively be used as a top-level graph, in which case the boundary variables are used directly.

\subsubsection{Properties}

\para{Solver}
\label{sec:FactorGraph.Solver}

Read-write.  Indicates the choice of solver to be used for performing inference on the graph.  The default solver is SumProduct.

When setting the solver, the solver is given by a string representing the name of the solver.  The solver name is case insensitive.

\begin{lstlisting}
fg.Solver = 'SolverName';
\end{lstlisting}

The current set of valid solver names are:

\begin{itemize}
\item SumProduct
\item MinSum
\item Gaussian
\item ParticleBP
\item Gibbs
\end{itemize}

A description of each of these solvers is given in section~\ref{sec:SolversAPI}.

Note that the solver can be modified at any time.  After running the solver on a graph, the solver may be modified and the new solver run using the same graph\footnote{In this case, care must be taken to set any solver-specific parameters to the new values after changing the solver.}.  One exception is that if solver-specific built-in factors (also referred to as ``custom factors'') are used in a graph, it is not possible to switch solvers (a list of solver-specific built-in factors is given at the end of section~\ref{sec:builtInFactors}).


\para{Scheduler}
\label{sec:FactorGraph.Scheduler}

Read-write.  Indicates the scheduler to be used for performing inference on the graph (unless a custom schedule is specified instead).

When setting the scheduler, the scheduler is given by a string representing the name of the scheduler.  The scheduler name is case \emph{sensitive}.

\begin{lstlisting}
fg.Scheduler = 'SchedulerName';
\end{lstlisting}

For all of the BP solvers (SumProduct, MinSum, Gaussian, ParticleBP), the following schedulers are available:

\begin{longtable}{l p{4in}}
\textbf{Name} & \textbf{Description} \\ \hline \hline
%
\textsf{DefaultScheduler} & Same as the TreeOrFloodingScheduler, which is the default if no scheduler or custom schedule is specified. \\ \hline
%
\textsf{TreeOrFloodingScheduler} & The solver will use either a Tree Schedule or a Flooding Schedule depending on whether the factor-graph contains cycles.  In a nested graph, this choice is applied independently in each subgraph.  If the factor-graph is a tree, the scheduler will automatically detect this and use a Tree Schedule.  In this schedule, each node is updated in an order that will result in the correct beliefs being computed after just one iteration.  If the entire graph is a tree, NumIterations should be set to 1, which is its default value.  If the factor-graph is loopy, the solver will instead use a Flooding Schedule (as described below). \\ \hline
%
\textsf{TreeOrSequentialScheduler} & The solver will use either a Tree Schedule (as described above) or a Sequential Schedule (as described below) depending on whether the factor-graph contains cycles.  In a nested graph, this choice is applied independently in each subgraph.  \\ \hline
%
\textsf{FloodingScheduler} & The solver will apply a Flooding Schedule.  For each iteration, all variable nodes are updated, followed by all factor nodes.  Because the graph is bipartite (factor nodes only connect to variable nodes, and vice versa), the order of update within each node type does not affect the result. \\ \hline
%
\textsf{SequentialScheduler} & The solver will apply a Sequential Schedule.  For each factor node in the graph, first, for each variable connected to that factor, the edge connecting the variable to the factor is updated; then the factor node is updated.  The specific order of factors chosen is arbitrary, and depends on the order that factors were added to the graph. \\ \hline
%
\textsf{RandomWithoutReplacementScheduler} & The solver will apply a Sequential Schedule with the order of factors chosen randomly without replacement.  On each subsequent iteration, a new random order is chosen.  Since the factor order is chosen randomly with replacement, on each iteration, each factor will be updated exactly once. \\ \hline
%
\textsf{RandomWithReplacementScheduler} & The solver will apply a Sequential Schedule with the order of factors chosen randomly with replacement.  On each subsequent iteration, a new random order is chosen.  The number of factors updated per iteration is equal to the total number of factors in the graph. However, since the factors are chosen randomly with replacement, not all factors are necessarily updated in a single iteration, and some may be updated more than once. \\ \hline
%
\end{longtable}


In a nested graph, for most of the schedulers listed above (except for the random schedulers), the schedule is applied hierarchically.  In particular, a subgraph is treated as a factor in the nesting level that it appears.  When that subgraph is updated, the schedule for the corresponding subgraph is run in its entirety, updating all factors and variables contained within according to its specified schedule.

It is possible for subgraphs to be designated to use a schedule different from that of its parent graph.  This can be done by specifying either a scheduler or a custom schedule for the subgraph prior to adding it to the parent graph.  For example:
%
\begin{lstlisting}
SubGraph.Scheduler = 'SequentialScheduler';
ParentGraph.addFactor(SubGraph, boundaryVariables);
ParentGraph.Scheduler = 'FloodingScheduler';
\end{lstlisting}

For the TreeOrFloodingScheduler and the TreeOrSequentialScheduler, the choice of schedule is done independently in the outer graph and in each subgraph.  In case that a subgraph is a tree, the tree scheduler will be applied when updating that subgraph even if the parent graph is loopy.  This structure can improve the performance of belief propagation by ensuring that the effect of variables at the boundary of the subgraph fully propagates to all other variables in the subgraph on each iteration.

For the RandomWithoutReplacementScheduler and RandomWithReplacementScheduler, if these are applied to a graph or subgraph, the hierarchy of any lower nesting layers is ignored.  That is, the subgraphs below are essentially flattened prior to schedule creation, and any schedulers or custom schedules specified in lower layers of the hierarchy are ignored.


Because of the differences in operation between the Gibbs solver and the BP based solvers, the Gibbs solver supports a distinct set of schedulers.  For the Gibbs solver, the following schedulers are available:

\begin{tabular}{l p{4in}}
\textbf{Name} & \textbf{Description} \\ \hline \hline
%
\textsf{GibbsDefaultScheduler} & Same as the GibbsSequentialScanScheduler, which is the default when using the Gibbs solver. \\ \hline
%
\textsf{GibbsSequentialScanScheduler} & The solver will apply a Sequential Scan Schedule.  For each scan, each variable is resampled in a fixed order.  The specific order of variables chosen is arbitrary, and depends on the order that variables were added to the graph. \\ \hline
%
\textsf{GibbsRandomScanScheduler} & The solver will apply a Random Scan Schedule.  Each successive variable to be resampled is chosen randomly with replacement.  The number of variables resampled per scan is equal to the total number of variables in the graph, but not all variables are necessarily resampled in a given scan, and some may be resampled more than once. \\ \hline
%
\end{tabular}

Because of the nature of the Gibbs solver, the nested structure of a graph is ignored in creating the schedule.  That is, the graph hierarchy is essentially flattened prior to schedule creation, and only the scheduler specified on the outermost graph is applied.



\para{Schedule}
\label{sec:FactorGraph.Schedule}

Read-write.  Specifies a custom schedule to be used for performing inference.  A custom schedule is in the form of a list of nodes or edges in the graph to be updated.  Specifically, a cell array where each entry is either a node in the graph (either variable or factor), or a cell array containing a neighboring pair of nodes (\{variable, factor\} or \{factor, variable\}).  The order of the entries in the cell array indicate the order that updates should be performed in a single iteration (or scan) when performing inference.  Examples of using custom schedules are given in section~\ref{sec:CustomSchedules}.

For all BP solvers, any of these entries may be included, and have the following interpretation.

\begin{description}
\item[Variable] Update messages for all outgoing edges of that variable.
\item[Factor] Update messages for all outgoing edges of that factor.
\item[\{Variable, Factor\}] Update a single outgoing edge of the variable in the direction connecting to the specified factor.
\item[\{Factor, Variable\}] Update a single outgoing edge of the factor in the direction connecting to the specified variable.
\end{description}

For BP solvers, a check is made when a custom schedule is set to ensure that all edges in the graph are updated at least once.

For the Gibbs solvers, the Schedule should include only variable entries.  Any other entries will be ignored.

If a custom schedule is set on a factor graph (either an entire graph or a sub-graph), this schedule is used instead of any built-in scheduler that may have previously been set (or the default scheduler).

In a nested graph, the Schedule property at each nesting level may be set independently.  For some built-in schedulers, the user may mix custom schedules at some nesting layers, while using built-in schedulers at others.  The particular built-in schedulers that support such mixing are described in section~\ref{sec:FactorGraph.Scheduler}.


\para{NumIterations}

Read-write.  The NumIterations property sets the number of iterations BP will to run when using the solve method.  This only applies to solvers that use BP, which are the SumProduct, MinSum, Gaussian, and ParticleBP solvers.

The default value is 1.  For a factor graph with a tree-structure, when using the default scheduler, one iteration is appropriate.  Otherwise, it would normally be appropriate to set the number of iterations to a larger value.

\para{NumSteps}

\para{Name}

Read-write.  When read, retrieves the current name of the factor graph.  When set, modifies the name of the factor graph to the corresponding value.  The value set must be a string.

\begin{lstlisting}
fg.Name = 'string';
\end{lstlisting}


%\para{QualifiedName}
%
%\para{ExplicitName}
%
%\para{Label}
%
%\para{QualifiedLabel}
%
%\para{UUID}
%
%\para{Nodes}
%
%\para{NodesFlat}
%
%\para{NodesTop}
%
%\para{Variables}
%
%\para{VariablesFlat}
%
%\para{VariablesTop}
%
%\para{Factors}
%
%\para{FactorsFlat}
%
%\para{FactorsTop}
%
%\para{NonGraphFactors}
%
%\para{NonGraphFactorsFlat}
%
%\para{NonGraphFactorsTop}
%
%\para{NestedGraphs}
%
%\para{FactorGraphStreams}
%
%\para{AdjacencyMatrix}

\para{Score}

\para{BetheFreeEnergy}

\para{BetheEntropy}

\para{InternalEnergy}


\subsubsection{Methods}

\para{initialize}

\begin{lstlisting}
MyGraph.initialize();
\end{lstlisting}

The initialize method resets the state of the factor graph and its associated solver.  When performing inference incrementally, for example using the iterate method, the initialize method must be called before the first iterate call.  When using the solve method to perform inference, there is no need to call initialize first.  The initialize method takes not arguments.

\para{solve}

\begin{lstlisting}
MyGraph.solve();
\end{lstlisting}

The solve method runs the solver on the factor graph for the specified duration.  Calling solve initializes the graph prior to solving.


\para{addFactor}

The addFactor (and related) methods are used to add a factor to a factor-graph, connecting that factor to a specified set of variables.  There are several ways of specifying the particular factor:

\begin{itemize}
\item A MATLAB function handle.
\item A sub-graph.
\item A factor-table.
\item A built-in factor.
\item A built-in overloaded MATLAB operator.
\item A custom Java FactorFunction object.
\end{itemize}

Each of these methods is summarized in the subsequent sections.

\subpara{MATLAB Function Handle}

A factor may be specified by defining a MATLAB function, and passing a handle to that function.  The function must accept values that correspond to the state of the connected variables (in the same order as specified in the addFactor call), and return a non-negative weight corresponding to the unnormalized value of the factor.

In this case, the “addFactor” method takes the following arguments:

\begin{itemize}
\item A function handle. 
\item A variable length list of Variables or matrices.
\end{itemize}

For example,

\begin{lstlisting}
MyGraph.addFactor(@XorDeltaTutorial,x,y,z);	
\end{lstlisting}

The ``@'' symbol indicates a function handle, where the function ``XorDeltaTutorial'' is assumed to exist somewhere in the current MATLAB path.

Using a MATLAB function to specify a factor is valid in Dimple only when all of the connected variables are discrete (either Discrete or Bit).  Real values are allowed in other parts of a graph, as long as they are not directly connected to this factor.

Some of the variables in the call may be replaced by constants.  In this case, no variable is created, but instead the specified constant value is used for the value of that input to the factor function.  The following shows an example of mixing variables and constants as arguments to the addFactor method.

\begin{lstlisting}
b = Bit(2,1);
MyGraph.addFactor(@XorDeltaTutorial,b(1),1, b(2));	
\end{lstlisting}

The constants can be any n-dimensional real or complex matrix.  

Adding a Factor in this way involves creating an array known as a factor table, which contains all assignments of the variables resulting in a positive value of the function, along with a value vector, containing all the corresponding values of the function. This table is then passed to the solver. Creating that table takes time (and typically space) proportional to the product of the size of the domains of all variables connected to that factor, thus requiring an exponential time in the degree of the factor.  The addFactor method attempts to save memory and time by re-using existing factors when addFactor is called with the same factor function.  The caching mechanism uses the name of the function (using MATLAB’s func2str) as well as the domain values for all of the arguments to addFactor when deciding if a FactorTable can be re-used.  If this behavior is undesirable, the addFactorNoCache method can be used instead of addFactor (see below).

\subpara{Nested Graphs}

In a nested graph, a sub-graph can be added to its parent graph using the addFactor method.  In this case, the first argument of the addFactor call is the sub-graph.  For example:

\begin{lstlisting}
MyGraph.addFactor(mySubGraph, a, b, c);
\end{lstlisting}

The number and order of the variables must correspond to the number and order of the connector variables declared when the sub-graph was created.

\subpara{Specifying FactorTables}

For all discrete factors, Dimple can build FactorTables under the hood. A Factor Table consists of a two dimensional array of integers and a single dimensional array of doubles. Each row of the two dimensional table represents a combination of variables for which the Factor Function returns a non-zero value. Each column represents a variable connected to the factor. The values of the table specify an index into the discrete domain of a variable. Each row of the two dimensional table corresponds to one entry of the array of doubles and that entry contains the return value of the Factor Function.

In some situations, a user might be able to build a FactorTable much more efficiently than Dimple can. Dimple tries all combinations of variable values exhaustively and discards combinations for which the Factor Function returns zeros. If the user can avoid this exhaustive search, they can build the FactorTable more quickly.

Once the user has created the table, they can add a Factor using this table in one of two ways. The first is to provide the indices and values directly to the addFactor call:

\begin{lstlisting}
   %First let's just add the factor as indices and values
   fg = FactorGraph();
   b = Bit(2,1);
   ind = [0 0; 1 1];
   val = [1 1];
   fg.addFactor(ind,val,b);
   b(1).Input = .8;
   fg.solve();
   assertEqual(b(2).Belief,.8);
\end{lstlisting}
   
Notice that the indices and values chosen here will be equivalent to creating an equals factor between the two variables. In the following example we see that it's possible to first create a Table and then add a factor using that table. This has the advantage of using less overall memory if this same table will be used in multiple factors.

\begin{lstlisting}
   %Now let's add the Factor using createTable to test we can share tables
   fg = FactorGraph();
   b = Bit(2,1);   
   t = FactorTable(ind,val,b.Domain,b.Domain);	
   fg.addFactor(t,b);
   b(1).Input = .8;
   fg.solve();
   assertEqual(b(2).Belief,.8);
\end{lstlisting}

Users can also create a FactorTable given a single n-dimensional matrix such that: $ val(x_1,...,x_n) = F(d_1(x_11),...,d_n(x_n)) $

Where val is the N dimensional matrix, F is the desired Factor Function, and di is a function mapping 1 based indices to domain elements of domain i.  This will result in an uncompressed table, so it doesn’t offer a speed improvement, but provides a convenient way to create Factors in some cases.

\begin{lstlisting}
   fg = FactorGraph();
   b = Bit(2,1);
   val = [1 0; 0 1];
   t = FactorTable(val,b.Domain,b.Domain);
   fg.addFactor(t,b);
   b(1).Input = .8;
   fg.solve();
   assertEqual(b(2).Belief,.8);
\end{lstlisting}

or equivalently:

\begin{lstlisting}
   fg = FactorGraph();
   b = Bit(2,1);
   val = [1 0; 0 1];
   fg.addFactor(val,b);
   b(1).Input = .8;
   fg.solve();
   assertEqual(b(2).Belief,.8);
\end{lstlisting}

In yet another way to specify FactorTables, users can create an empty Factor Table and use the “set” function to set values at specified domain combinations.

\begin{lstlisting}
   fg = FactorGraph();
   b = Discrete({'on','off'},2,1);
   t = FactorTable(b.Domain,b.Domain);
   t.set('on','on',1);
   t.set('off','off',1);
   fg.addFactor(t,b);
   b(1).Input = [.8 .2];
   fg.solve();
   assertEqual(b(2).Belief(1),.8);
\end{lstlisting}

Users can retrieve values using the FactorTable “get” function.

\begin{lstlisting}
>> t.get('on','on')

ans =

     1
\end{lstlisting}


\subpara{Built-in Factors}
\label{sec:builtInFactors}

Dimple supports a set of built-in factors that can be specified when adding a factor to a graph.  When calling the addFactor method, in many cases, the user may specify these functions by name (which is case sensitive).  In some cases, there are optional arguments for these built-in factor, in which case an alternative syntax must be used (see below).

As an example,

\begin{lstlisting}
Mean = Real();
InverseVariance = Real();
Values = Real(1,100);
MyGraph.addFactor('Normal', Mean, InverseVariance, Values);
\end{lstlisting}

The following table lists the current set of built-in Dimple factors.  For each, the name is given, followed by the set of variables that would be connected to the factor, followed by any constructor arguments.  Optional variables and constructor arguments are in brackets.  And an arbitrary length list or vector of variables is followed by ellipses.  The allowed set of variable data-types for each variable is given in parentheses (B = Bit, D = Discrete, or R = Real).  If no list is shown, then any data-type may be used.

\begin{longtable} {l p{2.2cm} p{2cm} p{7cm}}
Name & Variables & Constructor & Description \\
\hline
\endhead
%
Abs & out(D,R) \newline in(D,R) & [smoothing] & Deterministic absolute value function, where out = abs(in).  An optional smoothing value may be specified as a constructor argument\footnote{\label{ftn:smoothing}If smoothing is enabled, the factor function becomes $e^{-(\textrm{out} - F(\textrm{in}))^2/\textrm{smoothing}}$ (making it non-deterministic) instead of $\delta(\textrm{out} - F(\textrm{in}))$, where $F$ is the deterministic function associated with this factor.  This is useful for solvers that do not work well with deterministic real-valued factors, such as particle BP, particularly when tempering is used.}.\\
%
ACos & out(D,R) \newline in(D,R) & [smoothing] & Deterministic arc-cosine function, where out = acos(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
AdditiveNoise & out(R) \newline in(B,D,R) & $\sigma$ & Add Gaussian noise with a known standard deviation, $\sigma$, specified in constructor. \\
%
And & out(B) \newline in...(B) & - & Deterministic logical AND function, where out = AND(in...). \\
%
ASin & out(D,R) \newline in(D,R) & [smoothing] & Deterministic arc-sine function, where out = asin(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
ATan & out(D,R) \newline in(D,R) & [smoothing] & Deterministic arc-tangent function, where out = atan(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Beta & [$\alpha$](R) \newline [$\beta$](R) \newline value...(R) & [$\alpha$] \newline [$\beta$] & Beta distribution. There can be any number of value variables, all associated with the same parameter values.  Parameters $\alpha$ and $\beta$ can be variables, or if both are constant they can be specified in the constructor. \\
%
Categorical & $\alpha$...(R)  \newline x...(D) & N & Categorical distribution, $p(x | \alpha)$, where $\alpha$ is a vector of parameter variables and x is a vector of discrete variables.  The number of elements in $\alpha$ and the domain size of x must equal the value of the constructor argument, N.  There can be any number of x variables, all associated with the same parameter values.  \newline
The $\alpha$ parameters are represented as energy values, that is, $\alpha = -\log(\rho)$, where $\rho$ are unnormalized probabilities. The conjugate prior for this representation is such that each entry of $\alpha$ is independently distributed according to a negative exp-Gamma distribution, all with a common $\beta$ parameter (it is not necessary to use the conjugate prior, but in some cases there may be a benefit).  \newline
In the current implementation, the domain of the x variable must be zero-based contiguous integers, $0...N-1$ (this limitation may be lifted in a future version). \\
%
ConstantPower & out(D,R) \newline base(D,R) & power \newline [smoothing] & Deterministic power function, with a constant power. The power value is specified in the constructor. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
ConstantProduct & out(D,R) \newline in(D,R) & constant \newline [smoothing] &  Deterministic product function, multiplying the input times a constant value.  The constant value is specified in the constructor. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Cos & out(D,R) \newline in(D,R) & [smoothing] & Deterministic cosine function, where out = cos(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Cosh & out(D,R) \newline in(D,R) & [smoothing] & Deterministic hyperbolic-cosine function, where out = cosh(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
DiscreteTransition & x(D) \newline y(D) \newline A(R) & $N_{x}, N_{y} | \newline N$ & 
Parameterized discrete transition factor, $p(y | x, A)$, where x and y are discrete variables, and $A$ is a matrix of transition probabilities. The transition matrix is organized such that columns correspond to the output distribution for each input state. That is, the transition matrix multiplies on the left. The number of columns in A and the domain size of x must equal the value of the constructor argument, $N_{x}$ and the number of rows in A and the domain size of y must equal the value of the constructor argument $N_{y}$.  If $N_{x}$ and $N_{y}$ are equal, a single constructor argument, $N$, may be used.  \newline
The elements of the matrix A are represented as energy values, that is, $A_{i,j} = -\log(\rho_{i,j})$, where $\rho$ is an unnormalized transition probability matrix.  The conjugate prior for this representation is such that each entry of A is independently distributed according to a negative exp-Gamma distribution, all with a common $\beta$ parameter (it is not necessary to use the conjugate prior, but in some cases there may be a benefit).  \newline
In the current implementation, the domain of the x variable must be zero-based contiguous integers, $0...N-1$ (this limitation may be lifted in a future version). \\
%
Divide & quotient(D,R) \newline dividend(D,R) \newline divisor(D,R) & [smoothing] & Deterministic divide function, where $\mathrm{quotient} = \frac{\mathrm{dividend}}{\mathrm{divisor}}$. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Equality & value...(B,D,R) & [smoothing] & Deterministic equality constraint.  An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Equals & out(B) \newline in...(B,D,R) & - & Deterministic equals function, where out~=~(in(1)~==~in(2)~== ... ). \\
%
Exp & out(D,R) \newline in(D,R) & [smoothing] & Deterministic exponentiation function, where out = exp(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Gamma & [$\alpha$](R) \newline [$\beta$](R) \newline value...(R) & [$\alpha$] \newline [$\beta$] & Gamma distribution. There can be any number of value variables, all associated with the same parameter values.  Parameters $\alpha$ and $\beta$ can be variables, or if both are constant they can be specified in the constructor. \\
%
GreaterThan & out(B) \newline in1(B,D,R) \newline in2(B,D,R) & - & Deterministic greater-than function, where out = in1 $>$ in2.  \\
%
InverseGamma & [$\alpha$](R) \newline [$\beta$](R) \newline value...(R) & [$\alpha$] \newline [$\beta$] & Inverse Gamma distribution. There can be any number of value variables, all associated with the same parameter values.  Parameters $\alpha$ and $\beta$ can be variables, or if both are constant they can be specified in the constructor. \\
%
LessThan & out(B) \newline in1(B,D,R) \newline in2(B,D,R) & - & Deterministic greater-than function, where out = in1 $<$ in2.  \\
%
LinearEquation & out(D,R) \newline in(B,D,R) & constants \newline [smoothing] & Deterministic linear equation, multiplying an input vector by a constant vector. The constant vector is specified in the constructor.  The number of \emph{in} variables must equal the length of the constant vector. An optional smoothing value may be specified as a constructor argument\textsuperscript{\ref{ftn:smoothing}}. \\
%
Log & out(D,R) \newline in(D,R) & [smoothing] & Deterministic natural log function, where out = log(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
LogNormal & [$\mu$](R) \newline [$\tau$](R) \newline value...(R) & [$\mu$] \newline [$\tau$] & Log-normal distribution. There can be any number of value variables, all associated with the same parameter values.  Parameters $\mu$ (mean) and $\tau = \frac{1}{\sigma^{2}}$ (precision) can be variables, or if both are constant then fixed parameters can be specified in the constructor. \\
%
MatrixVectorProduct & y(D,R) \newline M(D,R) \newline x(D,R) & $N_{x}$ \newline $N_{y}$ \newline [smoothing] & Deterministic matrix-vector product function, $y = Mx$, where $x$ and $y$ are vectors and $M$ is a matrix. Constructor arguments, $N_{x}$ and $N_{y}$, specify the input and output vector lengths, respectively. The matrix dimension is $N_{y} \times N_{x}$. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
MixedNormal & value(R) \newline control(B) & $\mu_{0} \newline \tau_{0} \newline \mu_{1} \newline \tau_{1}$ & Simple mixture of two fixed-parameter Normal distributions. The choice of distribution parameters (0 vs. 1) is a function of the control bit. \\
%
Negate & out(D,R) \newline in(D,R) & [smoothing] & Deterministic negation function, where out = -in. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
NegativeExpGamma & [$\alpha$](R) \newline [$\beta$](R) \newline value...(R) & [$\alpha$] \newline [$\beta$] & Negative exp-Gamma distribution, which is a distribution over a variable whose negative exponential is Gamma distributed. That is, this is the negative log of a Gamma distributed variable. There can be any number of value variables, all associated with the same parameter values.  Parameters $\alpha$ and $\beta$ can be variables, or if both are constant they can be specified in the constructor, and correspond to the parameters of the underlying Gamma distribution. \\
%
Normal & [$\mu$](R) \newline [$\tau$](R) \newline value...(R) & [$\mu$] \newline [$\tau$] & Normal distribution. There can be any number of value variables, all associated with the same parameter values.  Parameters $\mu$ (mean) and $\tau = \frac{1}{\sigma^{2}}$ (precision) can be variables, or if both are constant then fixed parameters can be specified in the constructor. \\
%
Not & out(B) \newline in(B) & - & Deterministic logical NOT of function, where out = ~in. \\
%
NotEquals & out(B) \newline in...(B,D,R) & - & Deterministic not-equals function, where out~=~$\sim$(in(1)~==~in(2)~== ... ). \\
%
Or & out(B) \newline in...(B) & - & Deterministic logical OR function, where out = OR(in...). \\
%
Power & out(D,R) \newline base(D,R) \newline power(D,R) & [smoothing] & Deterministic power function, where out~=~base~$^{\mathrm{power}}$. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Product & out(D,R) \newline in...(B,D,R) & [smoothing] & Deterministic product function, where $\mathrm{out} = \prod \mathrm{in}$. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Rayleigh & [$\sigma$](R) \newline value...(R) & [$\sigma$] & Rayleigh distribution. There can be any number of value variables, all associated with the same parameter value.  Parameter $\sigma$ can be a variable, or if constant, can be specified in the constructor. \\
%
Sin & out(D,R) \newline in(D,R) & [smoothing] & Deterministic sine function, where out = sin(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Sinh & out(D,R) \newline in(D,R) & [smoothing] & Deterministic hyperbolic-sine function, where out = sinh(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Sqrt & out(D,R) \newline in(D,R) & [smoothing] & Deterministic square root function, where out = sqrt(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Square & out(D,R) \newline in(D,R) & [smoothing] & Deterministic square function, where out = in$^{2}$. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Subtract & out(D,R) \newline posIn(B,D,R) \newline negIn...(B,D,R) & [smoothing] & Deterministic summation function, where $\mathrm{out} = \mathrm{posIn} - \sum \mathrm{negIn}$. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Sum & out(D,R) \newline in...(B,D,R) & [smoothing] & Deterministic summation function, where $\mathrm{out} = \sum \mathrm{in}$. An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Tan & out(D,R) \newline in(D,R) & [smoothing] & Deterministic tangent function, where out = tan(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
Tanh & out(D,R) \newline in(D,R) & [smoothing] & Deterministic hyperbolic-tangent function, where out = tanh(in). An optional smoothing value may be specified as a constructor argument$^{\ref{ftn:smoothing}}$. \\
%
VonMises & [$\mu$](R) \newline [$\tau$](R) \newline value...(R) & [$\mu$] \newline [$\tau$] & Von Mises distribution. There can be any number of value variables, all associated with the same parameter values.  Parameters $\mu$ (mean) and $\tau = \frac{1}{\sigma^{2}}$ (precision) can be variables, or if both are constant then fixed parameters can be specified in the constructor.  The distribution is non-zero for value variables in the range $-\pi$ to $\pi$. \\
%
Xor & out(B) \newline in...(B) & - & Deterministic logical XOR function, where out = XOR(in...). \\
%
\end{longtable}

The above factors may be specified by name if no constructor arguments are needed.  If constructor arguments are needed, then there are two ways to specify the factor.  The preferred way is to create a FactorFunction object, which takes the name of the factor followed by the constructor arguments for that factor.  For example:

\begin{lstlisting}
MyGraph.addFactor(FactorFunction('Gamma', 1, 1), X);
\end{lstlisting}

The same FactorFunction can be used more than once, which avoids creating additional copies of the FactorFunction object.  For example:

\begin{lstlisting}
myFactorFunction = FactorFunction('Gamma', 1, 1);
MyGraph.addFactor(myFactorFunction, X1);
MyGraph.addFactor(myFactorFunction, X2);
\end{lstlisting}

A short-hand notation may alternatively be used, in which the name of the factor function and its constructor arguments are contained in a cell array.  For example:

\begin{lstlisting}
MyGraph.addFactor({'Gamma', 1, 1}, X);
\end{lstlisting}


In addition to the built-in factors listed above, there are a set of solver-specific built-in factors, also referred to as ``custom factors.''  These factors may also be specified by name in the addFactor call (using either a quoted string or as a function handle).  These are summarized in the following table:

\begin{longtable} {l p{3cm} p{7cm}}
Name & Solver & Description \\
\hline
\endhead
%
FiniteFieldFactor & SumProduct\footnote{\label{ftn:fff} These may also be used for discrete variables with the Gaussian or particle BP solvers, which use the sum-product solver for discrete-only portions of the graph.}  & See section~\ref{sec:finiteFields} \\ 
FiniteFieldProjection & SumProduct$^{\ref{ftn:fff}}$ & See section~\ref{sec:finiteFields} \\ 
FiniteFieldAdd & SumProduct$^{\ref{ftn:fff}}$ & See section~\ref{sec:finiteFields} \\ 
FiniteFieldConstMult & SumProduct$^{\ref{ftn:fff}}$ & See section~\ref{sec:finiteFields} \\ 
FiniteFieldMult & SumProduct$^{\ref{ftn:fff}}$ & See section~\ref{sec:finiteFields} \\ 
CustomXor & MinSum & Same as the Xor factor described above, but with a significantly faster implementation. \\ 
\end{longtable}


Dimple also includes some built-in helper functions to create structured graphs, combining smaller factors to form an efficient implementation of a larger subgraph.  Specifically, the following functions are provided.

\begin{itemize}
\item getNBitXorDef(n), where n is a positive integer. Returns a nestable graph and an array of n-Bit connector variables. Efficient tree implementation of the XORDelta function.
\item getVXOR(n), where n is a positive integer. Returns a nestable graph and an array of n-Bits connector variables. Constrains exactly one bit to be 1, and all others to be 0.
\end{itemize}




\subpara{Adding Factors Implicitly Using MATLAB Operators or Functions}

Dimple supports a set of built-in factors that can be added implicitly using overloaded MATLAB operators or functions.  For example,

\begin{lstlisting}
fg = FactorGraph();
a = Discrete(1:4);
b = Discrete(1:10);
c = a + b;
\end{lstlisting}

The last line of this example will create a new variable, c, and a 'Sum' factor with variables c, a, and b.  The domain of c will be defined appropriately given the domains of the input variables.  In this example, the domain of c would automatically be set to the range [2:14].

These operations can be compounded in a single line of code, and variables of different data types as well as constants can be intermingled (as long as the type is supported by the specific operator).  In this case, intermediate anonymous variables will be created in the graph associated with intermediate results of the operation.  For example,

\begin{lstlisting}
z = (a + b) * c^d - sqrt(-e);
\end{lstlisting}

Like using the addFactor method, adding factors implicitly can include constants.  Specifically, for binary operators, one of the inputs may be a constant instead of a variable.  For example:

\begin{lstlisting}
x = a^2;
y = (a + b + 2) * 3;
\end{lstlisting}

Since adding a factor implicitly does not specifically refer to the factor graph, the graph to which these factors are added is also implicit.  In particular, these implicitly defined factors are added to the last factor graph that was created.  So, in the first example above, the factor would be added to fg, regardless of whether other factor graphs had previously been created.

The specific set of operators supported is given in section~\ref{sec:overloaded}.



\subpara{Specifying Java Factor Functions}
\label{sec:userJava}

There are some cases in which it is desirable to add a factor function that is defined in Java rather than MATLAB. Specific cases where this is desirable are:

\begin{itemize}
\item The user wants to use a sample-based solver. Dimple's sample based solvers must use Java Factor Functions in order to be able to call the Factor Function at runtime. This is partly because MATLAB does not officially support callbacks from Java to MATLAB and also because calls from Java to Java will be faster than those that cross a language boundary.
\item The user wants their code to run faster. MATLAB function calls are very slow as compared to java function calls.
The following sections provides the steps users must follow to add a Java Factor Function to their FactorGraph.
\end{itemize}


\subparaNoToc{Create a Class That Inherits from Java FactorFunction}
\label{sec:createJavaFactorFunction}

Users must extend the FactorFunction class. They have to provide two methods:

\begin{itemize}
\item A constructor that call's the parent constructor.
\item An eval function that returns a weight for each possible set of inputs.
\end{itemize}

\begin{lstlisting}
import com.analog.lyric.dimple.FactorFunctions.core.FactorFunction;

/*
 * This factor enforces equality between all variables and weights
 * elements of the domain proportional to their value
 */
public class BigEquals extends FactorFunction
{	
    public BigEquals() 
    {
	super("BigEquals");
    }
  
    @Override
    public double eval(Object... input) throws Exception 
    {
	if (input.length == 0)
	    return 0;
	else
	{
	    double first = (Double) input[0];
	    
	    for (int i = 1; i < input.length; i++)
	    {
	        if ((Double)input[i] != first)
		    return 0;
	    }
	    return first;   
	}
    }
}
\end{lstlisting}

\subparaNoToc{Compiling}

The new class must be compiled to class files. Users can optionally create a jar file. If using Eclipse, users can simply create a new project, create the new class, and the .class files will be created automatically.

\subparaNoToc{Adding Binary to MATLAB Path}

In MATLAB, the user must use the javaaddpath call to add the java files to the javaclasspath.

\begin{lstlisting}
javaaddpath('<path to my project>/MyFactorFunctions/bin');
\end{lstlisting}

or

\begin{lstlisting}
javaaddpath('<path to the jar>/myjar.jar');
\end{lstlisting}

\subpara{Using the Factor Function}

Users can now instantiate the FactorFunction and call addFactor with the instance.

\begin{lstlisting}
be = BigEquals();
fg = FactorGraph(); 
v = Variable({0,1,2},2,1);
fg.addFactor(be,v(1),v(2));
fg.solve();
v(1).Belief
\end{lstlisting}

Note that the BigEquals class was added to the default package, so we can just call:

\begin{lstlisting}
be = BigEquals();
\end{lstlisting}

The previous code results in the following answer from MATLAB:

\begin{lstlisting}
ans =

   0.0000    0.3333    0.6667
\end{lstlisting}

\subparaNoToc{Re-using the Factor Function}
We can re-use the BigEquals() FactorFunction multiple times within a single graph or across graphs. This will result in caching of FactorTables when the arguments to the addFactor function have identical domains.

\begin{lstlisting}
be = BigEquals();
fg = FactorGraph(); 
v = Variable({0,1,2},2,1);
fg.addFactor(be,v(1),v(2));
fg.solve();
v(1).Belief

fg2 = FactorGraph();
v2 = Variable({0,1,2},2,1);
fg2.addFactor(be,v2(1),v2(2));
fg2.solve();
v2(1).Belief
\end{lstlisting}


\subpara{Constants}

Users can pass constants to addFactor.  The following passes the constant 1 to the xorDelta factor function as the final argument.

\begin{lstlisting}
fg = FactorGraph();
b = Bit(10,3);
fg.addFactorVectorized(@xorDelta,{b 1},1);
\end{lstlisting}


\para{addFactorNoCache}
\label{sec:addFactorNoCache}

There are several cases where Dimple’s factor caching mechanism is undesirable.  As an example, if the user is calling addFactor with the same factor many times, but they know the arguments are unique, they can save time by skipping the code that searches for a match in the cache. 

\begin{lstlisting}
fg = FactorGraph(); 
func = @(x,y) 1;
b = Bit(2,1);
for i=1:1000
fg.addFactorNoCache(func,b,rand());
end
\end{lstlisting}

This is a somewhat contrived example but, in this case, replacing addFactorNoCache with addFactor will significantly slow down the code.




\para{addFactorVectorized}

To get reasonable speed out of MATLAB, one needs to vectorize their code.  If a user wishes to build a FactorGraph with large numbers of factors in a regular arrangement, they will want to avoid making many calls to addFactor.  The addFactorVectorized method can be used instead to create many factors at once.

\subpara{Vectorizing over All Variables}

In this first example, we create three variable matrices and generate 12 factors connecting a(i,j), b(i,j), and c(i,j) for all i and j.

\begin{lstlisting}
fg = FactorGraph();
a = Bit(3,4);
b = Bit(3,4);
c = Bit(3,4);
fg.addFactorVectorized(@xorDelta,a,b,c);
\end{lstlisting}

\subpara{Specify Vectorize Dimensions}

By default addFactorVectorized will add factors for every dimension.  However, if a user wants to only vectorize over a subset of dimensions, addFactorVectorize
allows them to provide a cell array containing a variable matrix as the first argument and a list of dimensions to vectorize over as the second argument.  The following code will vectorize over the first two dimensions to create 12 xor factors.  Each xor factor is connected to 5 bits.

\begin{lstlisting}
fg = FactorGraph();
b = Bit(3,4,5);
fg.addFactorVectorized(@xorDelta,{b,[1 2]});
\end{lstlisting}

\subpara{Connecting a single variable with addFactorVectorized}

The addFactorVectorized method will ensure that dimensions being vectorized match for all inputs.  However, the call allows single variables to be connected to many as follows:

\begin{lstlisting}
fg = FactorGraph();
a = Bit(10,1);
b = Bit();
fg.addFactorVectorized(@xorDelta,a,b);
\end{lstlisting}

This will create a graph such that b is connected to every element of a via a total of 10 factors.

\subpara{repmat}

Similar things can be done with repmat.  Suppose you have a 10x1 vector of variables that you want connected to a 10x20 matrix of different variables.
The following code will create 200 factors.  Each element of a will be connected to 20 elements of b via 20 factors.

\begin{lstlisting}
fg = FactorGraph();
a = Bit(10,1);
b = Bit(10,20);
fg.addFactorVectorized(@xorDelta,repmat(a,1,10),b);
\end{lstlisting}

\subpara{Nested Graphs}

Nested Graphs are also supported

\begin{lstlisting}
a = Bit(3,1);
ng = FactorGraph(a);
ng.addFactor(@xorDelta,a);
fg = FactorGraph();
b = Bit(10,3);
fg.addFactorVectorized(ng,{b, 1});
\end{lstlisting}


\subpara{Adding Vectorized Factors Implicitly Using MATLAB Operators or Functions}

Adding built-in factors implicitly using overloaded MATLAB operators or functions can also be vectorized, with some limitations.  Specifically, if each of the input variables are vectors of the same dimension, then the result will be to create a vector of output variables of the same dimension, along with a vector of factors relating the inputs and outputs.

In some cases, to be consistent with MATLAB notation, there is a distinction made between the vectorized and non-vectorized operator.  Specifically, Dimple uses MATLAB's notation for point wise product and power operators to indicate a vectorized operation (currently using the matrix version of these operators on vector inputs is not supported).  For example, if variables a through e are vectors of variables of identical size, then the following would create a variable vector z, and a series of factors relating these variables.

\begin{lstlisting}
z = (a .* b) + c.^d - sqrt(-e);
\end{lstlisting}

For binary operators, one of the inputs may be a scalar variable or a scalar constant instead of a variable vector.  For a scalar variable, the result is that scalar variable connecting to each instance of the factors that are created.  For a constant, each instance of the factor uses the same constant for that input (vectors of distinct constants are not currently supported).  As an example:

\begin{lstlisting}
a = Real();
b = Discrete(domain, 1, 10);
z = a + b;					
\end{lstlisting}

The specific set of operators supported is given in section~\ref{sec:overloaded}.




\para{addDirectedFactor}

\para{addFactorNoCache}

\para{addRepeatedFactor}

\para{advance}

\para{hasNext}

\para{solveOneStep}

\para{continueSolve}

\para{baumWelch}

\para{estimateParameters}

Dimple provides support for estimating parameters.  In the current version of Dimple, only the SumProduct solver supports this feature.  The sum product algorithm computes the gradient of the BetheFreeEnergy and performs a gradient descent on this.  Users can specify how many times to restart the gradient descent with random table values.

\begin{lstlisting}
fg.estimateParameters({factorTable1,factorTable2,factor1,etc...}, numRestarts, numSteps, stepScaleFactor);
\end{lstlisting}

The estimateParameters method takes the following arguments:

\begin{itemize}
\item factorsAndFactorTables - A cell array of Factors or FactorTables for which parameters are to be estimated.  This list can include both Factors and FactorTables.
\item numRestarts - The number of times to randomly initialize the FactorTables and restart the gradient descent.
\item numSteps - The number of times to descend down along the gradient
\item stepScaleFactor - The value we scale the gradient by.
\end{itemize}


\para{join}

The join method can be used to join a set of existing variables or a set of existing factors in a graph.  In the current version of Dimple this method is supported only for discrete variables, and factors connected only to discrete variables.

When joining variables, the join method is called with a comma-separated list of variables to be joined.

\begin{lstlisting}
fg.join(variableList);
\end{lstlisting}

The result is a new variable with a domain that is the Cartesian product of the domains of all of the variables being joined.

When joining factors, the join method is called with a comma-separated list of factors to be joined.

\begin{lstlisting}
fg.join(factorList);
\end{lstlisting}

The result is a new factor with a factor table that corresponds to the product of the factors being joined.  The new factor connects with the union of all variables that were previously connected to any of the joined variables.


\para{split}

The split method splits a variable in an existing graph into two variables connected by an Equality factor.

\begin{lstlisting}
fg.split(variable, [factorList]);
\end{lstlisting}

The method takes an optional comma-separated list of factors.  This list of factors identifies factors already connected to the variable that are to be moved to the new instance of the variable.  All unspecified factors remain connected to the original instance.

\para{removeFactor}

\begin{lstlisting}
fg.removeFactor(factor);
\end{lstlisting}

This method removes the specified factor from an existing factor graph that contains it.  This also removes all edges that connect this factor to neighboring variables.

\para{plot}

The plot method is used to visualize a factor graph or a portion of a factor graph.  Examples of various use cases for plotting factor graphs are given in section~\ref{sec:PlottingAGraph}.

The plot method may be called with no arguments, or with a set of optional arguments.  The optional arguments are defined in the following table.  These are in the form of names (as strings) followed by one or more values.

\begin{longtable} {l p{3cm} p{10cm}}
Name & Values & Description \\
\hline
\endhead
\texttt{'labels'} & true/false & Boolean value indicating whether or not to display the name of each variable and factor node.  By default labels are not displayed. \\
\texttt{'color'} & [nodeList], color & Specifies the color of some or all nodes in the graph.  If no nodeList is included, then this specifies the color of all nodes in the graph.  If nodeList is specified, then the color applies to only the listed nodes.  The nodeList argument is a cell-array of nodes in the graph (factors and variables).  The color argument is a string indicating a MATLAB color (e.g., 'r').  More than one set of 'color' arguments may appear in a single call to plot. \\ 
\texttt{'nodes'} & nodeList & Indicates the set of nodes in the graph to be included in the plot.  The nodeList argument is a cell-array of nodes in the graph (factors and variables).  By default the entire graph is plotted.  \\
\texttt{'depth'} & rootNode, depth & This argument indicates a portion of the graph to be displayed by specifying a root node and depth (distance) from that node.  The plot includes only the root node and all other nodes that are within the specified distance from the root.  By default the entire graph is plotted.  \\
\texttt{'nesting'} & nestingDepth & By default, the plotting method ignores hierarchy and plots the flattened graph.  The nesting argument specifies how deep to descend into the nesting hierarchy before considering nested graphs to be factors and plotting them as such. \\
\end{longtable}





\subsubsection{Energy}

\para{Bethe Free Energy}

\[
BetheFreeEnergy = InternalEnergy - BetheEntropy
\]

\begin{lstlisting}
bfe = fg.BetheFreeEnergy;
\end{lstlisting}

\para{Internal Energy}

\[
 InternalEnergy = \sum_{a \in F }InternalEnergy(a) + \sum_{i \in V}InternalEnergy(i) 
 \]

Where F is the set of all Factors and V is the set of all variables.  If Dimple treated inputs as single node Factors, this method would only sum over factors.

\begin{lstlisting}
ie = fg.InternalEnergy;
\end{lstlisting}

\para{Bethe Entropy}

\[
 BetheEntropy = \sum_{a \in F}BetheEntropy(a) - \sum_{i \in V}BetheEntropy(i)(degree(i)-1) 
 \]

Where F is the set of all Factors and V is the set of all variables.

\begin{lstlisting}
be = fg.BetheEntropy;
\end{lstlisting}

\para{Factor Internal Energy}

\[
InternalEnergy(a) = \sum_{\vec{x} \in \vec{X}}B_a(\vec{x})*(-log(Weight(\vec{x}))) 
\]

Where a is an instance of a Factor, X is the set of variables connected to a, Weight is the FactorTable entry for the specified set of variable values, and B~a~ is the belief of that factor node.

\begin{lstlisting}
ie = f.InternalEnergy;
\end{lstlisting}

\para{Factor Bethe Entropy}

\[
BetheEntropy(a) = - \sum_{\vec{x} \in domain(\vec{X})}B_a(\vec{x})*log(B_a(\vec{x})) 
\]

Where a is an instance of a Factor, X is the set of variables connected to a, and B~a~ is the belief of that factor node.

\begin{lstlisting}
be = f.BetheEntropy;
\end{lstlisting}

\para{Variable Internal Energy}

\[
 InternalEnergy(i) = \sum_{d \in D}B_i(d)*(-log(Input(d))) 
 \]

Where D is variable i's domain and Input is the variable's input.

\begin{lstlisting}
ie = v.InternalEnergy;
\end{lstlisting}

\para{Variable Bethe Entropy}

\[
BentheEntropy(i) = - \sum_{d \in D}B_i(d)*log(B_i(d)) 
\]

Where D is variable i's domain.

\begin{lstlisting}
be = v.BetheEntropy();
\end{lstlisting}

Factor Belief

To support the Bethe Free Energy property, Dimple provides getBelief associated with a Factor.

\[
B_a(\vec{x}) = \frac{Weight(\vec{x})\prod_{i=0}^N \mu_{X_i \rightarrow a}(x_i)}{\sum_{\vec{x} \in \vec{X}}Weight(\vec{x})\prod_{i=0}^N \mu_{X_i \rightarrow a}(x_i\
)} 
\]

Where $ \vec{x} \in domain(\vec{X}) $ and $ \vec{X} $ is the set of variables connected to the factor a.

\begin{lstlisting}
b = f.Belief;
\end{lstlisting}

\para{Score}
\label{sec:score}

Users can retrieve the Energy of a Factor Graph, Variable Vector, or Factor. This feature is currently only supported with the SumProduct algorithm.

The following are examples of ways to retrieve the energy of FactorGraphs, factors, and variables:

\begin{lstlisting}
fg = FactorGraph();
b = Bit(3,1);
f = fg.addFactor(@xorDelta,b);

fg.Score
f.Score
b.Score
b(1).Score
\end{lstlisting}

When computing the score, the most likely variable value is used. It's possible to override that by setting a guess on a variable using:

\begin{lstlisting}
b.Guess = 1; %For other variable types, var.Guess takes a domain item.
\end{lstlisting}

\para{Math behind the score}

The variable energy is normalized by the maximum input probability.

\[
score(v) = -log(inputProb(guess) + log(max(inputProb)) 
\]

The factor energy is normalized by the largest factor value.

\[
score(f) = - log(f(guessxguessyguessz))+log(max(f)) 
\]

And the Factor Graph’s energy is as follows:

\[
score(fg) = \sum_{v \in V} score(v) + \sum_{f \in F} score(f) 
\]


\subsubsection{Introspection}

The FactorGraph class provides several feature for inspecting aspects of the graph.  The ability to nest graphs complicates things a bit.  Nested FactorGraphs can be considered Factors.  All of the introspection features allow the user to view nested graphs as leaf factors or to descend into them and operate on the children of the nested graphs.  Each feature provides several methods:

\begin{itemize}
\item $<$FeatureName$>$(int relativeNestingDepth) -- The relativeNestingDepth specifies how deep to descend into the nested FactorGraphs before treating deeper NestedGraphs as Factors.  Specifying 0 will treat the top level nested Graphs as factors.  Specifying a large enough number will descend all the way to the leaf factors.  Specifying something between 0 and the FactorGraph’s maximum depth will descend as far as this parameter specifies before considering NestedGraphs to be factors.  The parameter contains the word “relative” because users can retrieve nested graphs.  They can call one of the feature’s methods on that nested graph.  
\item $<$FeatureName$>$Flat() -- equivalent of $<$FeatureName$>$(max int)
\item $<$FeatureName$>$Top() -- equivalent of $<$FeatureName$>$(0)
\item $<$FeatureName$>$() -- equivalent of $<$FeatureName$>$Flat().  It was thought that users will most often want to operate on the FactorGraph in its flattened form.
\end{itemize}

Now, on to the specific features.

\para{Retrieving All Factors}

Users can retrieve Factors and/or NestedGraphs associated with a graph using the Factors methods and properties:

\begin{itemize}
\item Fg.Factors
\item Fg.FactorsFlat
\item Fg.FactorsTop
\item Fg.getFactors(relativeNestingDepth)
\end{itemize}

When the user specifies a relativeNestingDepth or calls FactorsTop, the resulting cell array will contain a mix of leaf factors and Nested Graphs.

\para{Retrieving Factors but not Nested Factor Graphs}

The FactorGraph class provides the following:

\begin{itemize}
\item NonFactorGraphFactors
\item NonFactorGraphFactorsFlat
\item NonFactorGraphFactorsTop
\item getNonFactorGraphFactors(relativeNestingDepth)
\end{itemize}

As the name implies, this will behave similar to the Factors properties and methods but will exclude nested graphs.

\para{Retrieving Variables}

The FactorGraph class provides the following:

\begin{itemize}
\item Variables -- calls VariablesFlat
\item VariablesFlat -- Returns a list of all the Variables in the graph, including those contained by nested graphs.
\item VariablesTop -- Returns only those variables contained in the top level of the graph.
\item getVariables(relativeNestingDepth,forceIncludeBoundaryVariables) -- Returns all variables contained in the FactorGraph from which the method is called as Variables that are as deep as the specified relativeNestingDepth.  The second parameter is optional and defaults to false.  When false, boundary variables are only included by the root graph.  When true, boundary variables are included regardless of whether a graph is a root or nested graph.
\end{itemize}

\para{Retrieving all Nodes}

The FactorGraph provides the following:

\begin{itemize}
\item Nodes
\item NodesFlat
\item NodesTop
\item getNodes(relativeNestingDepth,forceIncludeBoundaryVariables)
\end{itemize}

These methods call the Factor and Variable methods and concatenate the results together.

\para{Determining if a FactorGraph is a tree}

The FactorGraph class provides the following:

\begin{itemize}
\item isTree(relativeNestingDepth) 
\item isTreeTop 
\item isTreeFlat 
\end{itemize}


isTree -- Users can call <factor graph name>.isTree() to determine if a FactorGraph is a tree.  If the graph contains cycles, this method will return false. Like the other methods, the relativeNestingDepth determines at what point to consider NestedGraphs to be leaf cells.  

\para{Retrieving an Adjacency Matrix}

All of the following methods return a pair: [A, labels] where A is a square connectivity matrix and labels is a cell array of strings specifying the names of the nodes in A. 

\begin{itemize}
\item getAdjacencyMatrix(relativeNestingDepth,forceIncludeBoundaryVariables) -- relativeNestingDepth behaves the same as in other methods that take this parameter.  So does forceIncludeBoundaryVariables. forceIncludeBoundaryVariables has a default value of false.
\item getAdjacencyMatrix(nodes,forceIncludeBoundaryVariables) -- Users can specify a specific subset of nodes in which they’re interested.  This method will return an adjacency matrix with only those nodes.  Nodes are considered connected only if there is an edge directly connecting them.
\item getAdjacencyMatrixTop() -- equivalent to getAdjacencyMatrix(0,false)
\item getAdjacencyMatrixFlat() -- equivalent to getAdjacencyMatrix(intmax,false)
\end{itemize}

FactorGraph also provides an AdjacencyMatrix Property:

\begin{itemize}
\item AdjacencyMatrix -- equivalent to getAdjacencyMatrixFlat and only returns A (not the labels).  MATLAB properties can only return one object.
\end{itemize}

An example of getAdjacencyMatrix:

\begin{lstlisting}
fg = FactorGraph();
b = Bit(2,1);
b(1).Name = ‘b1’;
b(2).Name = ‘b2’;
f = fg.addFactor(@xorDelta,b);
f.Name = ‘f’;
[A,labels] = fg.getAdjacencyMatrix();
A =

     0     0     1
     0     0     1
     1     1     0


labels = 

    'b1'
    'b2'
    'f'
\end{lstlisting}

\para{Depth first search}

\begin{itemize}
\item depthFirstSearch(node, searchDepth, relativeNestingDepth) -- 
\begin{itemize}
\item node -- Specifies the node from which to initiate the search
\item searchDepth -- specifies how far from “node” the search should go.
\item relativeNestingDepth -- determines how deep to go down the NestedGraphs before considering NestedGraphs to be leaf cells. 
\end{itemize}
\item depthFirstSearchFlat(node, searchDepth) -- equivalent of depthFirstSearch(node,searchDepth,maxint)
\item depthFirstSearchThop(node, searchDepth) -- equivalent of depthFirstSearch(node,searchDepth,0)
\end{itemize}

An example:

\begin{lstlisting}
fg = FactorGraph();
b = Bit(6,1);
for i = 1:6
b(i).Name = sprintf('b%d',i);
end
f1 = fg.addFactor(@xorDelta,b(1:4));
f1.Name = 'f1';
f2 = fg.addFactor(@xorDelta,b(4:6));
f2.Name = 'f2';
 
nodes = fg.depthFirstSearch(b(1),3);
\end{lstlisting}

calling fg.plot(‘color’,b(1),’g’,’labels’,true) reveals the following structure of this graph

\includegraphics{images/Introspection.png}
 
As you might guess fg.depthFirstSearch(b(1),3) will return a collection of six nodes: b1, f1, b2, b3, b4, and f2.  It will not include b5 and b6 since those are at a depth of four from b1.





